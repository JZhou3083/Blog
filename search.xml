<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Count_of_smaller(leetcode 315)</title>
      <link href="/Blog/2022/08/18/Count-of-smaller/"/>
      <url>/Blog/2022/08/18/Count-of-smaller/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>这是一道leetcode的困难题目，直接给我做麻了。两个解法都看了很久，只好一边写总结一边整理思路希望能帮助理解和记忆。话不多说，直接上题目：</p><p>给你一个整数数组 nums ，按要求返回一个新数组 counts 。数组 counts 有该性质： counts[i] 的值是  nums[i] 右侧小于 nums[i] 的元素的数量。<br>Given an integer array nums, return an integer array counts where counts[i] is the number of smaller elements to the right of nums[i].</p><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [5,2,6,1]</span><br><span class="line">Output: [2,1,1,0]</span><br><span class="line">Explanation:</span><br><span class="line">To the right of 5 there are 2 smaller elements (2 and 1).</span><br><span class="line">To the right of 2 there is only 1 smaller element (1).</span><br><span class="line">To the right of 6 there is 1 smaller element (1).</span><br><span class="line">To the right of 1 there is 0 smaller element.</span><br></pre></td></tr></table></figure><p>这道题的解决思路有两个：离散化树状结构和合并排序。离散化是为了利用桶的概念，树状结构则是为了方便计算累加和。这边博客会提供具体解释。</p><h1 id="思路1：离散化树状结构"><a href="#思路1：离散化树状结构" class="headerlink" title="思路1：离散化树状结构"></a>思路1：离散化树状结构</h1><h2 id="离散化（桶）"><a href="#离散化（桶）" class="headerlink" title="离散化（桶）"></a>离散化（桶）</h2><p>我们一步步来，什么是离散化，为什么我们要离散化呢？离散化其实就是桶排序的变种。众所周知桶排序的缺陷是对待排序的数值有限制，比如不能是负数，不适用分布过于不均匀或者数值大小分布范围过大的序列。离散化就是针对这个问题的优化：如果我们直接对序列的每个元素建立一个映射函数，也就是每个元素作为一个桶，那么我最多只需要跟原序列一样长的桶的个数即可。</p><p>现在我们把原序列进行去重离散的到了对应的桶，我们可以对其桶排列，为什么就能做这道题呢？想一下，我们需要知道原序列每个元素后面比它小的数的个数，假如我对原序列从后往前遍历，将其放进对应的桶，并且计算之前的桶里面的元素个数，就可以得到我们想要的个数。最直观的理解可以去看leetcode<a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solution/ji-suan-you-ce-xiao-yu-dang-qian-yuan-su-de-ge-s-7/">官方答案</a>里面的ppt，这里我尽量一步步解释。</p><p>假设我们有个原序列 $nums&#x3D;[3,9,5,2,6,1,3]$，进行离散化建立桶，桶的$Keys&#x3D;[1,2,3,5,6,9]$，同时我们在建立一个哈系表来映射index的对应关系，得到一共六个桶（假设桶号从1开始）：</p><img src="/Blog/images/leetcode315_1.png" class="[bucket]" title="[3][3] " alt="Buckets"><p>此时准备工作就算完成了。那么我们开始遍历原序列：</p><ol><li>我们拿到原序列最右边元素$3$，放到对应的$3$号桶中。此时$3$号桶有一个元素。注意的是拿到的元素需要经过哈系表找到它的桶号码，假如我拿到$5$，我应该放到 $hashtable[5]&#x3D;4$ 号桶。然后我算一下$3$号桶前面的桶里面的元素个数，就是这个元素的结果，于是对于元素$3$目前是0：<img src="/Blog/images/leetcode315_2.png" class="[bucket]" title="[3][3] " alt="Buckets"></li><li>然后我们继续，这时候拿到了$1$,我们对应哈系表找到是$1$号桶。重复步骤一得到元素$1$的结果：<img src="/Blog/images/leetcode315_3.png" class="[bucket]" title="[3][3] " alt="Buckets"></li><li>重复步骤知道所有元素都遍历完，此处不继续详述。</li></ol><p>代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSmaller</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        unique = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(nums))) <span class="comment">#去重化并且排序</span></span><br><span class="line">        buckets = [<span class="number">0</span>]*<span class="built_in">len</span>(unique) <span class="comment"># 桶来了哦</span></span><br><span class="line">        res = [<span class="number">0</span>]*<span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;构建index的哈希表&quot;&quot;&quot;</span></span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(unique)):</span><br><span class="line">            hashtable[unique[i]] = i</span><br><span class="line">        <span class="string">&quot;&quot;&quot;遍历&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            num = nums[i]          </span><br><span class="line">            bucket_index = hashtable[num]</span><br><span class="line">            buckets[bucket_index] +=<span class="number">1</span></span><br><span class="line">            res[i] = <span class="built_in">sum</span>(buckets[:bucket_index])</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>结果： 这个算法能算出结果，但是它每个元素都需要计算前面所有桶元素个数的和，也即累计和，所以时间复杂度是$O(n^2)$，跟暴力解法相比只是做了点剪枝，是同一个级别的复杂度，所以跑超时了。所以我们引入了树状数组来优化求累计和的计算。</p><h2 id="树状数组-Binary-Index-Tree（BIT）"><a href="#树状数组-Binary-Index-Tree（BIT）" class="headerlink" title="树状数组 Binary Index Tree（BIT）"></a>树状数组 Binary Index Tree（BIT）</h2><h3 id="Why-BIT"><a href="#Why-BIT" class="headerlink" title="Why BIT"></a>Why BIT</h3><p>所谓树状数组，是一种用于高效处理对一个存储数字的列表进行更新及求前缀和的数据结构。它想优化的是列表更新操作的时间复杂度并保证求和操作依然高效。这是什么意思呢？假设我们有个长度为$n$的序列，我们想要高效的进行如下操作：</p><ol><li>更新 $update(idx,delta)$：对坐标为$idx$的元素进行更新</li><li>求累计和$prefixSum(idx)$: 求数组到$idx$所有（包含）所有元素的和</li><li>求范围和$rangeSum(from_{idx},to_{idx})$: 求数组从第$from_{idx}$到$to_{idx}$位置的所有数字的和</li></ol><p>对上述问题排除使用暴力累加求和的方法（就是上面我用的），另一种较简单的方法是使用$O(n)$的时间构造一个前缀数组，即该数组中的第$i$个位置保存原数组前$i$个元素的和，这样我们有：</p><ol><li>更新：只需要更新受次更新影响的前缀和，即从$idx$到最后一个位置的前缀和。时间复杂度为$O(n)$</li><li>求累计和：直接返回累计和。时间复杂度为$O(1)$</li><li>求范围和： 两段累计和相减即可。时间复杂度$O(1)$</li></ol><p>可以看出该方法求和非常高效，单个更新时间为线性时间。但是首先在本题目，我们是从后往前遍历，然后求前面累计和，没办法先构建出前面的累计和，不适用。其次在很多应用中更新操作较多，求和较少，这时方法就没那么高效，树状数组结构就是为了优化这种情况，它可以适当降低求和效率但是增强更新效率，使其都为$O(logn)$。</p><h3 id="How-it-work"><a href="#How-it-work" class="headerlink" title="How it work"></a>How it work</h3><p>BIT求和的基本思想在于，对于需要求和的位置$i$，例如$13$，我们可以用二进制表达法来进行分层求和：$13 &#x3D; 2^3+2^2+2^0$，则$prefixSum(13)&#x3D;rangeSum(1,8)+rangeSum(9,12)+rangeSum(13,13)$:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = [1, 7, 3, 0, 5, 8, 3, 2, 6, 2, 1, 1, 4, 5]</span><br><span class="line">prefixSum(13) = RANGE(1, 8) + RANGE(9, 12) + RANGE(13, 13)</span><br><span class="line">= 29 + 10 + 4 = 43</span><br></pre></td></tr></table></figure><p>假设我们能将上述的$rangeSum$提前算好的话，$predixSum(13)$可以直接相加求得。那么现在的问题是怎么计算和存储这样的二进制表示后所需的range sum呢？规则如下：</p><img src="/Blog/images/Binary_ranges.png" class="[BT]" title="[3][3] " alt="BT rules"><p>图中第一行为原数组，第二到第四行为依次按层填坑的过程。我们需要从左到右，从上到下依次将相应的值填入对应的位置中。最后一行中即为最终所形成的树状数组。</p><p>以图中第二行，也就是构造树状数组第一层的过程为例，我们首先需要填充的是数组中第一个数字开始，长度为__2的指数__个数字的区间内的数字的累加和。所以图中分别填充了从第一个数字开始，长度为$2^0, 2^1, 2^2, 2^3$的区间的区间和。到此为止这一步就结束了。因为2^4超过了我们原数组的长度范围。</p><p>下一步我们构造数组的第二层。与上一层类似，我们依然填充余下的空白中从第空白处一个位置算起长度为2的指数的区间的区间和。可以把每一段空白当成一个新的第一行，按照同样的规则来填补。类似地，第三层我们填充7-7，11-11和13-14区间的空白。以此类推知道填补玩所有的空白，此时我们构造了对应于输入数组的一个树状数组。将该数组即为BIT（方便起见，此处对此数组的索引为从1开始）</p><h4 id="求和与更新"><a href="#求和与更新" class="headerlink" title="求和与更新"></a>求和与更新</h4><p>利用构造好的的BIT数组可以方便的求累计和：</p><img src="/Blog/images/BTSum.png" class="[BT]" title="[3][3] " alt="BT"><p>所表示的树：</p><img src="/Blog/images/BTTree.png" class="[BT]" title="[3][3] " alt="BT"><p>可以总结出求和的规律：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">prefixSum(13) = prefixSum(0b00001101)</span><br><span class="line">= BIT[13] + BIT[12] + BIT[8]</span><br><span class="line">= BIT[0b00001101] + BIT[0b00001100] + BIT[0b00001000]</span><br></pre></td></tr></table></figure><p>可以观察到求累计和就是一个节点不断向上寻找母节点的行为，而母节点的坐标可以通过将当前节点坐标的二进制表达的最后一个$1$反转为$0$的过程，运算表达式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 13 = 0b00001101</span><br><span class="line">-x = -13 = 0b11110011</span><br><span class="line">x &amp; (-x) = 0b00000001</span><br><span class="line">x - (x &amp; (-x)) = 0b00001100</span><br></pre></td></tr></table></figure><p>接下来是更新。以$update(5,2)$为例，当想要给原数组地5个位置的数字家2,基于之前构造的BIT，更新的过程如下：</p><img src="/Blog/images/UpdateBIT.png" class="[BT]" title="[3][3] " alt="updateBIT"><p>从图可发现，除了第5个数字，BIT应当被更新的坐标为原坐标二进制表示最后一个1加上1所表示的数字，与上面求和刚好相反：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 5 = 0b00000101</span><br><span class="line">-x = -5 = 0b11111011</span><br><span class="line">x &amp; (-x) = 0b00000001</span><br><span class="line">x + (x &amp; (-x)) = 0b00000110</span><br></pre></td></tr></table></figure><h4 id="建立BIT"><a href="#建立BIT" class="headerlink" title="建立BIT"></a>建立BIT</h4><p>BIT的建立十分简单，我们只需要初始化一个权威0的数组，并对原数组的没一个位置对应的数字调用一次$update(i,delta)$即可，这是一个$O(nlogn)$的过程。此外存在一个优化为$O(n)$的算法，假设存在一个长度为$n$的输入数组$list$，其步骤如下（数组下表从0开始：</p><ol><li>初始化长度为$n+1$的BIT数组$bit$，并将$list$中的数字对应地放在$bit[1]$到$bit[n]$。</li><li>对于$1$到$n$的每一个$i$，进行如下操作：</li></ol><ul><li>令$j&#x3D;i+(i&amp;-i)$，若$j&lt;n+1$，则$bit[j]&#x3D;bit[j]+bit[i]$<br>原理此处不详述，感兴趣的同学可以去了解一下。</li></ul><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>不难看出，单次的更新和求累计和都最多需要访问$logn$个元素，孤儿时间复杂度为$O(logn)$。构建过程则取决于算法可为$O(nlogn)$或者$O(n)$。</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>好，现在我们终于学会了树状结构，来解决这道题目了。首先我们直接为树状数组结构建一个类（当然你也可以只创建操作函数）：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;BIT：Binary Indexed Tree 树状数组&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BIT</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n</span>):</span><br><span class="line">        self.tree = [<span class="number">0</span>] * (n+<span class="number">1</span>)     <span class="comment"># 比原数组多1个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lowbit</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, i, delta</span>):        <span class="comment"># 单点更新：执行+delta</span></span><br><span class="line">        i += <span class="number">1</span>                      <span class="comment"># 原数组下标转换到树状数组下标</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;<span class="built_in">len</span>(self.tree):</span><br><span class="line">            self.tree[i] += delta</span><br><span class="line">            i += self.lowbit(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">prefixSum</span>(<span class="params">self, i</span>):             <span class="comment"># 前缀和查询</span></span><br><span class="line">        i += <span class="number">1</span>                      <span class="comment"># 原数组下标转换到树状数组下标</span></span><br><span class="line">        summ = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&gt;<span class="number">0</span>:</span><br><span class="line">            summ += self.tree[i]</span><br><span class="line">            i -= self.lowbit(i)</span><br><span class="line">        <span class="keyword">return</span> summ</span><br></pre></td></tr></table></figure><p>好的，然后我们对之前的代码进行优化，我们对离散化之后的桶序列进行单点更新然后求累计和：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">countSmaller</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="string">&quot;&quot;&quot;&quot;离散化：绝对数值转秩次【rank从0开始】&quot;&quot;&quot;</span></span><br><span class="line">        unique = <span class="built_in">sorted</span>(<span class="built_in">list</span>(<span class="built_in">set</span>(nums))) <span class="comment">#去重化并且排序</span></span><br><span class="line">        hashtable = &#123;v:i <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(unique)&#125; <span class="comment"># 哈希表</span></span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;构建树状数组&quot;&quot;&quot;</span></span><br><span class="line">        tree = BIT(<span class="built_in">len</span>(unique))</span><br><span class="line"></span><br><span class="line">        <span class="string">&quot;&quot;&quot;从右往左遍历&quot;&quot;&quot;</span></span><br><span class="line">        res = [<span class="number">0</span>] * n</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):      </span><br><span class="line">            bucket_index = hashtable[nums[i]] <span class="comment"># 当前值的排名</span></span><br><span class="line">            tree.add(bucket_index,<span class="number">1</span>)    <span class="comment"># 单点更新+1</span></span><br><span class="line">            res[i] = tree.prefixSum(bucket_index-<span class="number">1</span>) <span class="comment">#累计和</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>自此题解，树状结构属于高级数据结构，不常要求掌握，但是因为比较有意思所以我还是学了一下。结果：</p><img src="/Blog/images/BIT_results.png" class="[BT]" title="[3][3] " alt="BIT result">]]></content>
      
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SubSort LCCI(leetcode 16)</title>
      <link href="/Blog/2022/08/18/subSort/"/>
      <url>/Blog/2022/08/18/subSort/</url>
      
        <content type="html"><![CDATA[<h2 id="Question-leetcode-16"><a href="#Question-leetcode-16" class="headerlink" title="Question leetcode 16"></a>Question leetcode 16</h2><p>Given an array of integers, write a method to find indices m and n such that if you sorted elements m through n, the entire array would be sorted. Minimize n - m (that is, find the smallest such sequence).</p><p>Return [m,n]. If there are no such m and n (e.g. the array is already sorted), return [-1, -1].</p><p>Example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input:  [1,2,4,7,10,11,7,12,6,7,16,18,19]</span><br><span class="line">Output:  [3,9]</span><br></pre></td></tr></table></figure><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>像这种想一次遍历就解决问题的大多数都要想到双指针了。老规矩，第一步在草稿上写一写找规律，进行思路转换：</p><ol><li>l指向的元素右边有元素比它小，所以只要从右边往左遍历，保存最小的值，与当前值比较。如果当前值比最小值小更新最小值，否则就更新l。</li><li>r也是类似，r左边存在元素比它大，所以只要从左边往右遍历，始终保存最大的值，与当前值比较。如果当前值比前面最大值大则更新最大值，否则更新r。</li></ol><p>故而只要遍历两遍就可以找到l和r。对于边缘情况，比如array是有序数组，l和r都是默认-1。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subSort</span>(<span class="params">self, array: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        minn,maxx = <span class="number">10</span>**<span class="number">7</span>, -<span class="number">10</span>**<span class="number">7</span> <span class="comment">#注意这里初始最值的选择</span></span><br><span class="line">        l,r = -<span class="number">1</span>, -<span class="number">1</span></span><br><span class="line">        N = <span class="built_in">len</span>(array)</span><br><span class="line">        <span class="comment"># 从右往左找l</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> array[i]&lt;=minn:</span><br><span class="line">                minn = array[i]</span><br><span class="line">            <span class="keyword">else</span>: l = i  </span><br><span class="line">        <span class="comment">#从左往右找r</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="keyword">if</span> array[j]&gt;=maxx:</span><br><span class="line">                maxx = array[j]</span><br><span class="line">            <span class="keyword">else</span>: r = j</span><br><span class="line">        <span class="keyword">return</span> [l,r]</span><br></pre></td></tr></table></figure><p>The result:</p><img src="/Blog/images/leetcode16.png" class="[leetcode]" title="[3][3] " alt="results">]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sum of Elements(leetcode 1)</title>
      <link href="/Blog/2022/08/17/ElementSum/"/>
      <url>/Blog/2022/08/17/ElementSum/</url>
      
        <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>这篇文章是leetcode刷题日记：在数组中选出几个元素其和为一个目标值。这种类型的题目由简入深可以通过增加元素的个数，从两数之和到四数之和。也可以变动一下条件到与target最接近。这种题目的暴力解法就是穷举法，但是可以通过排序+双指针大大减小时间复杂度。</p><h3 id="Two-Sum（Leetcode-1"><a href="#Two-Sum（Leetcode-1" class="headerlink" title="Two Sum（Leetcode 1)"></a>Two Sum（Leetcode 1)</h3><p>Given an array of integers $nums$ and an integer $target$, return indices of the two numbers such that they add up to $target$. You may assume that each input would be <em>have exactly one solution</em> and you may not use the same elements twice. (Can you come up with an algorithm that is less than $O(n^2) time complexity$.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>As sorting of array in Python has $O(nlogn)$ time complexity, and using double pointers has $O(n)$ time complexity, it is easy to solve the problem with $O(nlogn)$ time complexity overall:</p><ul><li>Make a hash table to save the original index</li><li>Sort the array using sort() method in Python</li><li>Have a pointer $left$ pointing at the first element and a pointer $right$ pointing at the end of array</li><li>Calculate the sum of elements pointed by the pointers, if:</li></ul><ul><li>The sum equals to the target, add the element index to the output</li><li>The sum is smaller than the target, move the pointer $left$ one step to the right</li><li>The sum is greater than the target, move the pointer $right$ a step to the left.</li></ul><ul><li>Stop when two pointers meet</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self,nums:<span class="type">List</span>[<span class="built_in">int</span>],target:<span class="built_in">int</span></span>)-&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums)&lt;<span class="number">2</span>:</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    <span class="comment"># Construct hashtable</span></span><br><span class="line">    hashtable = <span class="built_in">dict</span>()</span><br><span class="line">    <span class="keyword">for</span> i,num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">      <span class="keyword">if</span> num <span class="keyword">in</span> hashtable:</span><br><span class="line">        hashtable[num].append(i) <span class="comment"># if repetitive numbers</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        hashtable[num] = [i]</span><br><span class="line">    nums.sort()</span><br><span class="line">    l,r = <span class="number">0</span>, <span class="built_in">len</span>(nums)-<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l&lt;r:</span><br><span class="line">      total = nums[l]+nums[r]</span><br><span class="line">      <span class="keyword">if</span> total == target:</span><br><span class="line">        <span class="keyword">if</span> nums[l]==nums[r]:</span><br><span class="line">          <span class="keyword">return</span> hashtable[nums[l]][:<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">          <span class="keyword">return</span> hashtable[nums[l]][<span class="number">0</span>],hashtable[nums[r]][<span class="number">0</span>]</span><br><span class="line">      <span class="keyword">elif</span> total&lt;target:</span><br><span class="line">        l += <span class="number">1</span></span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        r -= <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>The total time complexity is therefore $O(nlogn)$ and space complexity: $O(n)$. However, the time complexity is due to the sorting instead of traversing, are there even better solution? The answer is yes.</p><h3 id="Better-solution"><a href="#Better-solution" class="headerlink" title="Better solution"></a>Better solution</h3><p>Since we use a hash table, why not just loop over the numbers and look for the another element from its precedents so that we don’t need to sort the array? Dictionary structure allows $O(1)$ time complexity of ‘checking back’ therefore sorting is no longer necessary:</p><ul><li>Create a hash table in the form of a dictionary</li><li>Loop over the array, at the $i$th element:</li></ul><ul><li>If there isn’t another index of element in the hash table that can get the target by summing with $nums[i]$, store $i$ into the harsh table</li><li>If there is another, output its index and $i$ as solution</li></ul><p>In such way, no sorting is required and we only need to traverse the array once, leading to a time complexity $O(n)$ and space complexity $O(n)$.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target- num <span class="keyword">in</span> hashtable:</span><br><span class="line">                <span class="keyword">return</span> hashtable[target-num], i</span><br><span class="line">            hashtable[num] = i</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><h2 id="Three-sum-leetcode-15"><a href="#Three-sum-leetcode-15" class="headerlink" title="Three sum (leetcode 15)"></a>Three sum (leetcode 15)</h2><p>Now spice it up! Given an integer array sums, return all the triplets $nums[i], nums[j], nums[k]$ such that $nums[i]+nums[j]+nums[k] &#x3D; 0$. Notice that the solution set must not contain duplicate triplets.</p><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-1,0,1,2,-1,-4]</span><br><span class="line">Output: [[-1,-1,2],[-1,0,1]]</span><br><span class="line">Explanation:</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.</span><br><span class="line">The distinct triplets are [-1,0,1] and [-1,-1,2].</span><br><span class="line">Notice that the order of the output and the order of the triplets does not matter.</span><br></pre></td></tr></table></figure><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>Easily it can be observed that the time complexity of Brute force method is $O(n^3)$. We can simply it by loop over only the first element then use the same method used for twoSum problem looking for the next two elements, which is sorting+double pointers. In such way, the time complexity is reduced to $O(n^2+nlogn)&#x3D;O(n^2)$, where the $nlogn$ comes from the sorting:</p><ul><li>Sort the array</li><li>Loop over the array for the first, also the smallest element among three $nums[i]$</li><li>Use the two pointers $left$ and $right$ to locate the other elements, look for the steps in the previous problem</li></ul><p>Cuttings can be achieved by early stopping. For instance, when the first element $nums[i]$ is greater than the target 0 already, we can stop the algorithm. Also, if for $nums[i]$, the maximum summation: $nums[i]+nums[n-2]+nums[n-1]$ is smaller than target, or the minimum summation: $nums[i]+nums[i+1]+nums[i+2]$ is greater than target, we can safetly say not further looking for suitable $left$ and $right$ is needed.</p><p>However, this two checking will be done at the end of traversing for the two pointers anyway so it is your job to check if the “jumped checking” is saving much calculation. In the problem “Four Sum” this is certainly the case, which will be demonstrated in the later section.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="built_in">len</span>(nums)&lt;<span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> []        </span><br><span class="line">        nums.sort() <span class="comment"># sorting first:O(nlogn)</span></span><br><span class="line"></span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">            <span class="comment"># early stop since no way the later elements will make the sum smaller</span></span><br><span class="line">            <span class="keyword">if</span> nums[i]&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">            <span class="comment"># jump over repeating elements as there won&#x27;t be new solutions for the same\\</span></span><br><span class="line">            <span class="comment"># 1st number</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            L = i+<span class="number">1</span></span><br><span class="line">            R = N-<span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> L&lt;R:</span><br><span class="line">                total = nums[i]+nums[L]+nums[R]</span><br><span class="line">                <span class="keyword">if</span> total&lt;<span class="number">0</span>:</span><br><span class="line">                    L +=<span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> total&gt;<span class="number">0</span>:</span><br><span class="line">                    R -=<span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    res.append([nums[i],nums[L],nums[R]])</span><br><span class="line">                    <span class="keyword">while</span> L&lt;R <span class="keyword">and</span> nums[L]==nums[L+<span class="number">1</span>]:</span><br><span class="line">                        L+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> L&lt;R <span class="keyword">and</span> nums[R]==nums[R-<span class="number">1</span>]:</span><br><span class="line">                        R-=<span class="number">1</span></span><br><span class="line">                    L+=<span class="number">1</span></span><br><span class="line">                    R-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><h2 id="Complex-variants"><a href="#Complex-variants" class="headerlink" title="Complex variants"></a>Complex variants</h2><h3 id="Three-sum-closest-leetcode-16"><a href="#Three-sum-closest-leetcode-16" class="headerlink" title="Three sum closest (leetcode 16)"></a>Three sum closest (leetcode 16)</h3><p>Given an integer array $nums$ of length $n$ and an integer $target$, find the three integers in nums such that the sum is closest to the $target$. Return the sum of the three integer and you may assume a sole solution.</p><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [-1,2,1,-4], target = 1</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure><h3 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h3><p>The difference is just now we need to keep a record of the best solution and tried all the solutions:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">threeSumClosest</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        nums.sort()</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        best = <span class="number">10</span>**<span class="number">7</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 根据差值的绝对值来更新答案</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">cur</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> best</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(cur - target) &lt; <span class="built_in">abs</span>(best - target):</span><br><span class="line">                best = cur</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 枚举 a</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="comment"># 保证和上一次枚举的元素不相等</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i - <span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># 使用双指针枚举 b 和 c</span></span><br><span class="line">            j, k = i + <span class="number">1</span>, n - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &lt; k:</span><br><span class="line">                s = nums[i] + nums[j] + nums[k]</span><br><span class="line">                <span class="comment"># 如果和为 target 直接返回答案</span></span><br><span class="line">                <span class="keyword">if</span> s == target:</span><br><span class="line">                    <span class="keyword">return</span> target</span><br><span class="line">                update(s)</span><br><span class="line">                <span class="keyword">if</span> s &gt; target:</span><br><span class="line">                    <span class="comment"># 如果和大于 target，移动 c 对应的指针</span></span><br><span class="line">                    k0 = k - <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> j &lt; k0 <span class="keyword">and</span> nums[k0] == nums[k]:</span><br><span class="line">                        k0 -= <span class="number">1</span></span><br><span class="line">                    k = k0</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果和小于 target，移动 b 对应的指针</span></span><br><span class="line">                    j0 = j + <span class="number">1</span></span><br><span class="line">                    <span class="comment"># 移动到下一个不相等的元素</span></span><br><span class="line">                    <span class="keyword">while</span> j0 &lt; k <span class="keyword">and</span> nums[j0] == nums[j]:</span><br><span class="line">                        j0 += <span class="number">1</span></span><br><span class="line">                    j = j0</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> best</span><br></pre></td></tr></table></figure><h2 id="Four-sum"><a href="#Four-sum" class="headerlink" title="Four sum"></a>Four sum</h2><p>Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:</p><ul><li>0 &lt;&#x3D; a, b, c, d &lt; n</li><li>a, b, c, and d are distinct.</li><li>nums[a] + nums[b] + nums[c] + nums[d] &#x3D;&#x3D; target</li></ul><p>You may return the answer in any order.</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>The idea is the same. We just need to find as much as cutting we can do to speed up the searching:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fourSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> <span class="built_in">len</span>(nums)&lt;<span class="number">4</span>:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        res = []</span><br><span class="line">        N = <span class="built_in">len</span>(nums)</span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">3</span>):</span><br><span class="line">            <span class="comment"># if i==2: print(nums[i])</span></span><br><span class="line">            <span class="keyword">if</span> i&gt;<span class="number">0</span> <span class="keyword">and</span> nums[i]==nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="comment"># early stop</span></span><br><span class="line">            <span class="keyword">if</span> nums[i] + nums[i + <span class="number">1</span>] + nums[i + <span class="number">2</span>] + nums[i + <span class="number">3</span>] &gt; target:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,N-<span class="number">2</span>):</span><br><span class="line">                <span class="keyword">if</span> j&gt;i+<span class="number">1</span> <span class="keyword">and</span> nums[j]==nums[j-<span class="number">1</span>]:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                <span class="comment"># early stop</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] + nums[j+<span class="number">1</span>] + nums[j + <span class="number">2</span>] &gt; target:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] + nums[j] + nums[N - <span class="number">2</span>] + nums[N - <span class="number">1</span>] &lt; target:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                l, r = j+<span class="number">1</span>, N-<span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l&lt;r:</span><br><span class="line">                    total = nums[i]+nums[j]+nums[l]+nums[r]</span><br><span class="line">                    <span class="keyword">if</span> total==target:</span><br><span class="line">                        res.append([nums[i],nums[j],nums[l],nums[r]])</span><br><span class="line">                        <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> nums[l]==nums[l+<span class="number">1</span>]:</span><br><span class="line">                            l+=<span class="number">1</span></span><br><span class="line">                        <span class="keyword">while</span> l&lt;r <span class="keyword">and</span> nums[r]==nums[r-<span class="number">1</span>]:</span><br><span class="line">                            r-=<span class="number">1</span></span><br><span class="line">                        l+=<span class="number">1</span></span><br><span class="line">                        r-=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">elif</span> total&lt;target:</span><br><span class="line">                        l+=<span class="number">1</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        r-=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> res     </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>We need to be extra careful to distinguish when to stop the whole looping and when to jump over the current iteration only when we are cutting the traversing. Such questions all follows the same idea: sorting+double pointers. Any better methodologies I can come up in the future I will add them up to this post.</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorting - Bucket</title>
      <link href="/Blog/2022/08/12/bucketSort/"/>
      <url>/Blog/2022/08/12/bucketSort/</url>
      
        <content type="html"><![CDATA[<h1 id="Bucket"><a href="#Bucket" class="headerlink" title="Bucket"></a>Bucket</h1><p>虽然这篇文章标题是桶排序，但是我打算把计数排序，桶排序和基数排序一块儿总结了。因为实际上他们都是运用了桶的概念，只是对桶的使用上有点差异：</p><ul><li>计数排序：每个桶只存储一个键值</li><li>桶排序：每个桶存储一定范围的键值</li><li>基数排序：根据键值的位值来分配桶</li></ul><p>引入桶是为了构建一个从键值到index的映射函数，毕竟排序的本质其实就是根据键值的大小关系来重新决定index。桶方法都是空间换时间。如果没理解可以继续往下，然后回来对照就可以明白了。</p><h1 id="Counting-Sort"><a href="#Counting-Sort" class="headerlink" title="Counting Sort"></a>Counting Sort</h1><p>计数排序最容易理解，根据输入的数据值将其存在额外开辟的数组空间。比如一个数是55,那么它被存在新的数组空间的第55个位置。这样键值的大小直接与其在新数组的位置对应起来，最后只需要按序把新数组的数字提取出来就可以了。计数算法是一种线性算法（毕竟只需要存储和提取各一次即可）。但是它要求数据必须是有确定范围的整数，因为index不能为小数，而且一开始新数组的大小最好就确定。一个动图如下：<br><img src="/Blog/images/countingSort.gif" alt="GIF"></p><p>它的实现代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countingSort</span>(<span class="params">arr,maxValue</span>):</span><br><span class="line">  bucketlen = maxValue+<span class="number">1</span></span><br><span class="line">  bucket=[<span class="number">0</span>]*bucketlen</span><br><span class="line">  sortedIndex = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> num <span class="keyword">in</span> arr: <span class="comment">#构建存储数组</span></span><br><span class="line">    bucket[num] += <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(bucketlen):</span><br><span class="line">    <span class="keyword">while</span> bucket[i]:</span><br><span class="line">      arr[sortedIndex] = i</span><br><span class="line">      sortedIndex += <span class="number">1</span></span><br><span class="line">      bucket[i] -= <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h1 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h1><p>桶排序其实是一种方法论，计数排序一个桶只存储一个值，桶则存一定范围。桶的范围可以我们根据需要自己决定。当把所有数分配到桶之后，在桶内执行排序，当然你可以在桶里继续分（递归）都取决与你。理想状态下，数据被均匀的分配，可以大幅度降低时间复杂度，最差的情况则是所有数据分到一个桶。其次，桶选的太多也会占用不必要的额外空间。还有如果你的数据分布非常不均匀的话，桶排序就时间收益不大同时又消耗无谓的空间。为了使其高效，通常需要：</p><ol><li>在额外空间重组的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的$N$个数据尽可能均匀地分布在$K$个桶中。<br>同时，对桶内的排序的算法也很重要。</li></ol><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bucket_sort 代码实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">List</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">bucket_sort</span>(<span class="params">arr:<span class="type">List</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;桶排序&quot;&quot;&quot;</span></span><br><span class="line">    min_num = <span class="built_in">min</span>(arr)</span><br><span class="line">    max_num = <span class="built_in">max</span>(arr)</span><br><span class="line">    <span class="comment"># 桶的大小</span></span><br><span class="line">    bucket_range = (max_num-min_num) / <span class="built_in">len</span>(arr)<span class="comment"># 如果分布不均匀，映射函数也可以是非线性的</span></span><br><span class="line">    <span class="comment"># 桶数组</span></span><br><span class="line">    count_list = [ [] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr) + <span class="number">1</span>)]</span><br><span class="line">    <span class="comment"># 向桶数组填数</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        count_list[<span class="built_in">int</span>((i-min_num)//bucket_range)].append(i)</span><br><span class="line">    arr.clear()</span><br><span class="line">    <span class="comment"># 回填，这里桶内部排序直接调用了sorted</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> count_list:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">sorted</span>(i):<span class="comment">#这里直接用list的排序O(nlogn)来桶内排序</span></span><br><span class="line">            arr.append(j)</span><br></pre></td></tr></table></figure><p>这里不对桶排序的时间复杂度进行分析，对此有兴趣的可参考<a href="https://segmentfault.com/a/1190000022767400">这篇文章</a>。</p><h1 id="Radix-Sort"><a href="#Radix-Sort" class="headerlink" title="Radix Sort"></a>Radix Sort</h1><p>基数排序也是整数非比较型排序，起源历史将整数按位数切割，用位数来进行比较。因为整数也可以用来表达字符串或特定格式的浮点数，所以基数排序不是只能用于整数：</p><p><img src="/Blog/images/radixSort.gif" alt="GIF"></p><p>实现代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">radix</span>(<span class="params">arr</span>):</span><br><span class="line"></span><br><span class="line">    digit = <span class="number">0</span></span><br><span class="line">    max_digit = <span class="number">1</span></span><br><span class="line">    max_value = <span class="built_in">max</span>(arr)</span><br><span class="line">    <span class="comment">#找出列表中最大的位数</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">10</span>**max_digit &lt; max_value:</span><br><span class="line">        max_digit = max_digit + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> digit &lt; max_digit:</span><br><span class="line">        temp = [[] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="comment">#求出每一个元素的个、十、百位的值</span></span><br><span class="line">            t = <span class="built_in">int</span>((i/<span class="number">10</span>**digit)%<span class="number">10</span>)</span><br><span class="line">            temp[t].append(i)</span><br><span class="line"></span><br><span class="line">        coll = []</span><br><span class="line">        <span class="keyword">for</span> bucket <span class="keyword">in</span> temp:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> bucket:</span><br><span class="line">                coll.append(i)</span><br><span class="line"></span><br><span class="line">        arr = coll</span><br><span class="line">        digit = digit + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>总而言之，桶是一种建造由数值到index的映射关系的办法（岂不是某种哈希函数？），缺陷是对数组的范围有限制。比如计数排序无法排序负数等等。但是在待排序数组合适，使用恰当的时候，桶方法是线性的排序办法，非常高效。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://segmentfault.com/a/1190000022767400">Python实现： 十大排序算法之桶排序（Bucket Sort</a></p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ensemble learning</title>
      <link href="/Blog/2022/08/10/Model-Combination/"/>
      <url>/Blog/2022/08/10/Model-Combination/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>Ensemble learning is a common way to improve date modeling performance in classification or regression problems. As I have recently been enrolled in a Kaggle competition hosted by Huawei: recommendation system for user CTR prediction, I reviewed the chapter 14 of the PRML book. This blog is a summary of the model combining ideas including bagging, boosting and stacking.</p><p>This blog focus more on the theory than mathematically equations since most of the methods are supported by Python&#x2F;R libraries, hence readers interested in the proving process are referred to the book.</p><h3 id="Model-combination-Vs-Bayesian-Model-Averaging"><a href="#Model-combination-Vs-Bayesian-Model-Averaging" class="headerlink" title="Model combination Vs Bayesian Model Averaging"></a>Model combination Vs Bayesian Model Averaging</h3><p>To start with, I would like to emphasize that model combination methods are different from Bayesian Model Averaging: Bayesian Model Averaging assumes the whole data set is generated by a single Model that lies in a model distribution set, and the probability distribution simply reflects the uncertainty on which model is generating. With the increasing data set size, the uncertainty decrease.</p><p>On the other hand, model combination methods see that different points within the data set can potentially be generated by a single model. Therefore, either averaging the results of all models, or selecting the right models for the specific data region can achieve better performance than a single model.</p><h2 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h2><p>Everything are decided by the committee.</p><p>It is really down to one question: how the committee of models make decisions. An easy strategy to naturally start with is Voting, which is common in classification problems. Weighted Averaging is more often used in the regression problems.</p><p>As in practice, we only have a single data set where we have to find a way to introduce variability between models within the committee. One approach is to use bootstrap data sets: we sample a sub set from the training set and construct a new model on the subset. Suppose we generate $M$ bootstrap data sets and the committee prediction is given by:<br>$$y_{com}(x) &#x3D; \frac{1}{M}\sum_{m&#x3D;1}^{M}y_m(x)$$</p><p>This procedure is known as bootstrap aggregation or bagging. Random Forest is an example where the base models are decision trees. The randomness means while creating new decision tree models, it randomly choose features from the total to ensure uncorrelateness between the decision tress.</p><p>(The limitation of decision tree is that the division of the input space is based on hard splits in which only one model is responsible for prediction making for any given value of the input variables. This can be soften by moving to a probabilistic framework. For further detail, one can read Section 14.5 of the book.)</p><p>One advantage of Bagging is it allows parallel training of the base models. However, it assumes that the errors due to the individual models are uncorrelated, which usually is not the case but it still can achieve better performance than any single models. This is why boosting comes in.</p><h2 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h2><p>As a variant of committee, boosting is an iterative method: it trains the model sequentially and allocate higher weights to the data points mis-classified by the previous models. Common methods include AdaBoost, GBDT.</p><img src="/Blog/images/boosting1.png" class="[sort]" title="[3][3] " alt="Boosting1"><img src="/Blog/images/boosting2.png" class="[sort]" title="[3][3] " alt="Boosting2"><h2 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h2><p>Stacking is a very powerful method and frequently used in Kaggle competitions for performance boosting. The aim is to get enlarged data set for uncorrelated committee models. It took me some reading on an explanation to understand its mechanism from <a href="https://zhuanlan.zhihu.com/p/26890738">here</a> and this <a href="https://www.youtube.com/watch?v=xtTyEoJ31Vg">video</a>.</p><p>The idea of stacking and blending is similar: using the predictions of the based models (level-0) as the input features to construct a meta model (level-1). (Think about that: the meta model is doing a similar job of what the last layer of a neural network does). What the difference between stacking and blending is stacking uses K-fold:</p><img src="/Blog/images/stacking.png" class="[sort]" title="[3][3] " alt="Stacking"><p>The implementation steps of stacking is all on the training set:</p><ul><li>Split training data set into n-folds</li><li>Now train the first base model using the n-1 folds data and make predictions on the test fold, save the predictions</li><li>continue doing the step 2 for the base model n times until it produce prediction data set of same size of the original training data set</li><li>repeated step 2&amp; 3 for every baseline models, eventually you will have predictions from all the base models on the whole training data set.</li><li>Now construct the level 1 model, also named meta model who uses the predictions of all the base models as input features, the target value of the original training set as the target.</li></ul><p>The final model we obtain is the base models and a meta model, combined as a double-layered model. As it is widely supported by the Scikit libraries, the raw code of implementation will not be given but a demon usage code:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Importing pakages</span></span><br><span class="line"><span class="keyword">from</span> sklearn.ensemble <span class="keyword">import</span> RandomForestClassifier</span><br><span class="line"><span class="keyword">from</span> skelearn.svm <span class="keyword">import</span> LinearSVC</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegresssion</span><br><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> model_selection</span><br><span class="line"><span class="keyword">from</span> mlxtend.classifier <span class="keyword">import</span> StackClassifier</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating dataset</span></span><br><span class="line"><span class="keyword">from</span> sklearn importdatasets</span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X_train,y_train = iris.data[:,<span class="number">1</span>:<span class="number">3</span>], iris.target <span class="comment">#using the entire dataset as training sets</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Defining base leaerners</span></span><br><span class="line">mycl1 = KNeighborsClassifier(n_neighbors =<span class="number">1</span>)</span><br><span class="line">mycl2 = RandomForestClassifier(random_state =<span class="number">1</span>)</span><br><span class="line">mycl3 = GaussianNB()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Defining meta model</span></span><br><span class="line">mylr = LogisticRegresssion()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating stacking classifier with above models</span></span><br><span class="line">stackingclf = StackingClassifier(classifiers = [mycl1,mycl2,mycl3], meta_classifier = mylr)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Let&#x27;s start!</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Doing 3-fold cross validation here:\n&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> iterclf, iterlable <span class="keyword">in</span> <span class="built_in">zip</span>([myclf1,mycl2,mycl3,stackingclf],</span><br><span class="line">[<span class="string">&#x27;K-Nearest Neighbour Model&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Random Forest Model&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Naive Bayes Model&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Stacking Classifier Model&#x27;</span>]</span><br><span class="line">):</span><br><span class="line">scores = model_selection.cross_val_score(iterclf,X_train,y_train, cv =<span class="number">3</span>,scorinng=<span class="string">&#x27;accuracy&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Accuray: %.3f(+/- %.3f) [%s]&#x27;</span> % (scores.mean(),scores.std(),iterlabel))</span><br></pre></td></tr></table></figure><p>Paste the code to your Python compiler and have a go!</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/26890738">Kaggle 机器学习之模型融合（Stacking）心得</a></li><li><a href="https://www.youtube.com/watch?v=xtTyEoJ31Vg">Stacking and BLending in ensemble machine learning</a></li><li><a href="https://www.javatpoint.com/stacking-in-machine-learning#:~:text=Stacking%20is%20one%20of%20the,new%20model%20with%20improved%20performance.">Stacking in Machine Learning</a></li><li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2006/01/Bishop-Pattern-Recognition-and-Machine-Learning-2006.pdf">Pattern Recognition and machine Learning，Chrisopher M. Bishop</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> PRML notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> machine learning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Find Unique Binary String</title>
      <link href="/Blog/2022/07/29/Algorithms/Find-Different-Binary-String/"/>
      <url>/Blog/2022/07/29/Algorithms/Find-Different-Binary-String/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Reference: <a href="https://leetcode.cn/problems/find-unique-binary-string/solution/kang-tuo-dui-jiao-xian-by-seedjyh-wr2s/">康托对角线</a></p></blockquote><h1 id="Leecode-1980"><a href="#Leecode-1980" class="headerlink" title="Leecode 1980"></a>Leecode 1980</h1><p>Given an array of strings $nums$ containing $n$ <strong>unique</strong> binary strings each of length $n$, return a binary string of length $n$ that <strong>does not appear</strong> in $nums$. If there are multiple answers, you may return <strong>any</strong> of them.</p><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [&quot;01&quot;,&quot;10&quot;]</span><br><span class="line">Output: &quot;11&quot;</span><br><span class="line">Explanation: &quot;11&quot; does not appear in nums. &quot;00&quot; would also be correct.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [&quot;00&quot;,&quot;01&quot;]</span><br><span class="line">Output: &quot;11&quot;</span><br><span class="line">Explanation: &quot;11&quot; does not appear in nums. &quot;10&quot; would also be correct.</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>第一个方法来自leedcode官方答案，即转化为整数。首先建立一个哈希表，把数列中所有二进制字符串转换为对应的十进制并存起来。然后从0到最大范围的数进行遍历，发现第一个不存在于哈希表的数字就将其转换回二进制字符串返回输出。这种方法属于笨方法，因为预处理数列构造哈希表的时间复杂度为$O(n^2)$。寻找不在哈希表的数并转换回来则为$O(n)$。空间复杂度为$O(n)$，即为哈希表的空间复杂度。代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDifferentBinaryString</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">      <span class="built_in">hash</span> = &#123;<span class="built_in">int</span>(num,<span class="number">2</span>) <span class="keyword">for</span> num <span class="keyword">in</span> nums&#125; <span class="comment"># 哈希表构建</span></span><br><span class="line">      value = <span class="number">0</span></span><br><span class="line">      <span class="keyword">while</span> value <span class="keyword">in</span> <span class="built_in">hash</span>:</span><br><span class="line">        value+=<span class="number">1</span></span><br><span class="line">      <span class="comment"># 转换回来</span></span><br><span class="line">      binary_str = &#123;<span class="number">0</span>:b&#125;.<span class="built_in">format</span>(value) <span class="comment">#method 1</span></span><br><span class="line">      binary_str = <span class="built_in">str</span>(<span class="built_in">bin</span>(value)[<span class="number">2</span>:]) <span class="comment"># method 2</span></span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>*(<span class="built_in">len</span>(nums)-<span class="built_in">len</span>(binary_str))+binary_str</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>方法2 来自网络大神<a href="https://leetcode.cn/u/seedjyh/">seedjyh</a>，运用了康托对角线的反证法，对这个反证明过程不熟悉的可以看一下<a href="https://zhuanlan.zhihu.com/p/38397182">文章</a>。大概意思就是想要找到不存在数列中的字符串，我们可以自己来构建一个。怎么构建呢，假如我依次读取数列中的字符串，修改每个字符串的某一位然后把这个新的位赋给新字符串，新的字符串可以保证与每个字符串都不一样（简直是妙脆角他妈给妙脆角开門，妙到家了）。因为只需要遍历一次数列，时间复杂度为$O(n)$，空间复杂度为$O(1)$。代码如下：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findDifferentBinaryString</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(<span class="built_in">ord</span>(nums[i][i])^<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)))</span><br></pre></td></tr></table></figure><p>其中$ord()$和$chr()$ 函数是unicode码与字符的转换函数，$^$负责0和1的转换。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorting - Heap Sort</title>
      <link href="/Blog/2022/07/27/HeapSort/"/>
      <url>/Blog/2022/07/27/HeapSort/</url>
      
        <content type="html"><![CDATA[<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><p>堆排序的原理在之前’Queue for moving window’的博客涉及到过，指的是利用堆这种数据结构来进行排序。堆是一种完全二叉树，即树的结构只有最后一层右边能有缺省。其次，根据父节点和子节点的大小关系分为：</p><ul><li>大顶堆：每个节点的值都大于或等于其子节点的值。</li><li>小顶堆：每个节点的值都小于或等于其字节点的值。</li></ul><p>那么为什么堆排序能用来排序呢？首先，父节点和子节点的坐标有联系，比如第$i$个节点，它的左子节点的坐标是$2i+1$ (假设index从0开始)。如果对每个节点都与其子节点进行比较调整，相当于可以进行跳步比较。而且父节点只会存在前半序列，故而只需要对序列的前半部分进行操作即可。注意的是，调整是从后往前的，也即序列的中间网首往前，因为这样能保证最小（大）的元素逐渐冒到顶端。调整完得到的堆的堆顶即当前最小（大）的元素。此过程的时间复杂度为$O(logn)$。</p><p>然后，把堆顶元素取出来，把堆尾放到堆顶，重新进行调整，得到第二小（大）的元素。以此类推。值得注意的是堆只是概念上的数据结构，实际的数据结构仅仅是数组而已，堆排序空间复杂度很优良，为$O(1)$，属于$in-place$算法。时间复杂度为$O(nlogn)$。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ol><li>把待排序序列构建成一个堆$H[0,…n-1]$，根据需求选择大顶堆或者小顶堆</li><li>把堆首与堆尾进行调换，然后去掉堆尾的元素</li><li>吧堆的尺寸减小一，重新进行调整</li><li>重复2,3 直到堆的尺寸为1</li></ol><h1 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h1><p><img src="/Blog/images/heapSort.gif" alt="GIF"></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>上代码：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">buildMaxHeap</span>(<span class="params">arr</span>): <span class="comment">#构建大顶堆</span></span><br><span class="line">    <span class="keyword">import</span> math</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(math.floor(<span class="built_in">len</span>(arr)/<span class="number">2</span>),-<span class="number">1</span>,-<span class="number">1</span>):</span><br><span class="line">        heapify(arr,i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapify</span>(<span class="params">arr, i</span>):</span><br><span class="line">    left = <span class="number">2</span>*i+<span class="number">1</span></span><br><span class="line">    right = <span class="number">2</span>*i+<span class="number">2</span></span><br><span class="line">    largest = i</span><br><span class="line">    <span class="keyword">if</span> left &lt; arrLen <span class="keyword">and</span> arr[left] &gt; arr[largest]:</span><br><span class="line">        largest = left</span><br><span class="line">    <span class="keyword">if</span> right &lt; arrLen <span class="keyword">and</span> arr[right] &gt; arr[largest]:</span><br><span class="line">        largest = right</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        swap(arr, i, largest)</span><br><span class="line">        heapify(arr, largest) <span class="comment">#父子互换后需要对新子节点进行堆话，不影响新父节点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">arr, i, j</span>):</span><br><span class="line">    arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">heapSort</span>(<span class="params">arr</span>):</span><br><span class="line">    <span class="keyword">global</span> arrLen</span><br><span class="line">    arrLen = <span class="built_in">len</span>(arr)</span><br><span class="line">    buildMaxHeap(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(arr)-<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">        swap(arr,<span class="number">0</span>,i)</span><br><span class="line">        arrLen -=<span class="number">1</span></span><br><span class="line">        heapify(arr, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorting - Quick Sort</title>
      <link href="/Blog/2022/07/27/QuickSort/"/>
      <url>/Blog/2022/07/27/QuickSort/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Reference:<a href="https://www.geeksforgeeks.org/why-quick-sort-preferred-for-arrays-and-merge-sort-for-linked-lists/">Why Quick Sort prefered for Arrays and Merge Sort for Linked Lists?</a></p></blockquote><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>快速排序是东尼霍尔发明的一种排序算法，在大数据数组排序问题中是最常用的办法。理论上最坏情况下需要$O(n^2)$, 但这种情况可以通过随机化来尽量避免使得大部分情况下为$O(nlogn)$。已知合并排序最坏情况也是$O(nlogn)$， 为什么快速排序更常用呢？</p><h1 id="快速排序-VS-合并排序"><a href="#快速排序-VS-合并排序" class="headerlink" title="快速排序 VS 合并排序"></a>快速排序 VS 合并排序</h1><p>合并排序有一个很大的问题就是空间复杂度为$O(n)$，在大数据量的情况下，合并排序会造成巨大的存储压力，而且拖慢合并算法的效率。而快速排序可以通过选择合适的$pivotal$来尽力避免最坏情况。但与此同时，快速排序需要频繁的从数列调取数据，如果数列是以链表的形式存储，调取元素则会拖慢快速排序。 此时用合并算法会更优，因为可以通过指针实现$O(1)$插入元素。更详细的解释可以参考这篇文章！<a href="https://www.geeksforgeeks.org/why-quick-sort-preferred-for-arrays-and-merge-sort-for-linked-lists/">快速排序和合并排序对比</a></p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ol><li>从数列中挑选一个元素成为’基准’(pivot);</li><li>重新排序数列，所有比基准小的元素放在基准前面，所有比基准大的元素昂在基准后面。在这个分区推出之后，可以保证该基准处于数列中间位置（其实就是吧这个基准排列好了）。这个称为分区（partition）操作;</li><li>递归地把小于基准值元素的子数列和大于基准值的子数列排序。</li></ol><h1 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h1><p><img src="/Blog/images/quickSort.gif" alt="GIF"></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>老规矩， 先递归：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr,left,right</span>):</span><br><span class="line">  pivot = left</span><br><span class="line">  index = pivot+<span class="number">1</span></span><br><span class="line">  i = index</span><br><span class="line">  <span class="keyword">while</span> i &lt;= right:</span><br><span class="line">    <span class="keyword">if</span> arr[i] &lt; arr[pivot]: <span class="comment">#比基准小则与index换位置</span></span><br><span class="line">      arr[i],arr[index] = arr[index],arr[i]</span><br><span class="line">      index+=<span class="number">1</span></span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line">  <span class="comment"># 此时index开始的元素都比基准大，index前面的都比基准小(除了arr(0)</span></span><br><span class="line">  arr[pivot],arr[index-<span class="number">1</span>] = arr[index-<span class="number">1</span>],arr[pivot]</span><br><span class="line">  <span class="keyword">return</span> index-<span class="number">1</span> <span class="comment"># 其实是原来的pivot</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">qucikSort</span>(<span class="params">arr, left = <span class="literal">None</span>, right = <span class="literal">None</span></span>):</span><br><span class="line">  left = <span class="number">0</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(left,(<span class="built_in">int</span>,<span class="built_in">float</span>)) <span class="keyword">else</span> left</span><br><span class="line">  right = <span class="built_in">len</span>(arr)-<span class="number">1</span> <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(right,(<span class="built_in">int</span>,<span class="built_in">float</span>)) <span class="keyword">else</span> right</span><br><span class="line">  <span class="keyword">if</span> left &lt; right:</span><br><span class="line">    partitionIndex = partition(arr,left, right)</span><br><span class="line">    qucikSort(arr,left,partitionIndex-<span class="number">1</span>)</span><br><span class="line">    quickSort(arr,partitionIndex+<span class="number">1</span>,right)</span><br><span class="line">  <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure><p>可见分区函数会把比pivot小的放pivot左边，大的放右边，并且返回cishipivot的坐标。也就是说pivot已经被排好序，不用再考虑了。这就是为什么在排序函数里面，partion完之后只需要对左右的子序列分别进行再排序。接下来是迭代法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This function is same in both iterative and recursive</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">arr, l, h</span>):</span><br><span class="line">    i = ( l - <span class="number">1</span> )</span><br><span class="line">    x = arr[h]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(l, h):</span><br><span class="line">        <span class="keyword">if</span>   arr[j] &lt;= x:</span><br><span class="line"></span><br><span class="line">            <span class="comment"># increment index of smaller element</span></span><br><span class="line">            i = i + <span class="number">1</span></span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line"></span><br><span class="line">    arr[i + <span class="number">1</span>], arr[h] = arr[h], arr[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> (i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Function to do Quick sort</span></span><br><span class="line"><span class="comment"># arr[] --&gt; Array to be sorted,</span></span><br><span class="line"><span class="comment"># l  --&gt; Starting index,</span></span><br><span class="line"><span class="comment"># h  --&gt; Ending index</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quickSortIterative</span>(<span class="params">arr, l, h</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create an auxiliary stack</span></span><br><span class="line">    size = h - l + <span class="number">1</span></span><br><span class="line">    stack = [<span class="number">0</span>] * (size)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># initialize top of stack</span></span><br><span class="line">    top = -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># push initial values of l and h to stack</span></span><br><span class="line">    top = top + <span class="number">1</span></span><br><span class="line">    stack[top] = l</span><br><span class="line">    top = top + <span class="number">1</span></span><br><span class="line">    stack[top] = h</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Keep popping from stack while is not empty</span></span><br><span class="line">    <span class="keyword">while</span> top &gt;= <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Pop h and l</span></span><br><span class="line">        h = stack[top]</span><br><span class="line">        top = top - <span class="number">1</span></span><br><span class="line">        l = stack[top]</span><br><span class="line">        top = top - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set pivot element at its correct position in</span></span><br><span class="line">        <span class="comment"># sorted array</span></span><br><span class="line">        p = partition( arr, l, h )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># If there are elements on left side of pivot,</span></span><br><span class="line">        <span class="comment"># then push left side to stack</span></span><br><span class="line">        <span class="keyword">if</span> p-<span class="number">1</span> &gt; l:</span><br><span class="line">            top = top + <span class="number">1</span></span><br><span class="line">            stack[top] = l</span><br><span class="line">            top = top + <span class="number">1</span></span><br><span class="line">            stack[top] = p - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># If there are elements on right side of pivot,</span></span><br><span class="line">        <span class="comment"># then push right side to stack</span></span><br><span class="line">        <span class="keyword">if</span> p + <span class="number">1</span> &lt; h:</span><br><span class="line">            top = top + <span class="number">1</span></span><br><span class="line">            stack[top] = p + <span class="number">1</span></span><br><span class="line">            top = top + <span class="number">1</span></span><br><span class="line">            stack[top] = h</span><br><span class="line">   <span class="keyword">return</span> arr</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 快速排序和合并排序我都之看了递归法，有志之士可以研究一下迭代法提高代码能力。。。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorting - Merge Sort</title>
      <link href="/Blog/2022/07/25/mergeSort/"/>
      <url>/Blog/2022/07/25/mergeSort/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Merge sort is a classical application of Divide and Conquer method. As Divide and Conquer method usually can be achieved with either recursion or iteration. This article will only discuss both the recursion and iterative way.</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ol><li>申请空间，使其大小为两个已经排序序列之和，用来存放合并后的序列</li><li>设定两个指针，最初位置分别为两个已经排序的起始位置</li><li>比较两个指针所致想的元素，选择相对晓得元素放入合并空间，并移动指针到下一位</li><li>重复步骤3知道指针到达序列尾</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><p>上面的合并过程相对容易理解，但是建立在两个序列都已经排列好的情况。那么在初始给定一个未排列好的序列时，怎么利用这个合并法呢。此时即分治法发挥作用的时候了： w我们可以将一个初始序列分成两半，对两个序列分别进行排序，然后再对排列好的子序列进行合并。如此持续的二分直到拆分到只有一个元素，此时是不是可以看成是一个已排序的序列。</p><h1 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h1><p><img src="/Blog/images/mergeSort.gif" alt="GIF"></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>先看递归法：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先建立合并程序</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">left, right</span>):</span><br><span class="line">  result = []</span><br><span class="line">  <span class="keyword">while</span> left <span class="keyword">and</span> right:</span><br><span class="line">    <span class="keyword">if</span> left[<span class="number">0</span>]&lt;right[<span class="number">0</span>]:</span><br><span class="line">      result.append(left[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      result.append(right[<span class="number">0</span>])</span><br><span class="line">  <span class="keyword">while</span> left:</span><br><span class="line">    result.append[left.pop(<span class="number">0</span>)]</span><br><span class="line">  <span class="keyword">while</span> right:</span><br><span class="line">    result.append[right.pop(<span class="number">0</span>)]</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="comment">#  分治法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeSort</span>(<span class="params">arr</span>):</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(arr)&lt;<span class="number">2</span>:</span><br><span class="line">    <span class="keyword">return</span> arr</span><br><span class="line">  mid = <span class="built_in">len</span>(arr)//<span class="number">2</span></span><br><span class="line">  left,right = arr[<span class="number">0</span>:mid], arr[mid:]</span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br></pre></td></tr></table></figure><p>众所周知，能递归的都可以迭代：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Iterative Merge sort (Bottom Up)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Iterative mergesort function to</span></span><br><span class="line"><span class="comment"># sort arr[0...n-1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># perform bottom up merge</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeSort</span>(<span class="params">a</span>):</span><br><span class="line"><span class="comment"># start with least partition size of 2^0 = 1</span></span><br><span class="line">width = <span class="number">1</span></span><br><span class="line">n = <span class="built_in">len</span>(a)</span><br><span class="line"><span class="comment"># subarray size grows by powers of 2</span></span><br><span class="line"><span class="comment"># since growth of loop condition is exponential,</span></span><br><span class="line"><span class="comment"># time consumed is logarithmic (log2n)</span></span><br><span class="line"><span class="keyword">while</span> (width &lt; n):</span><br><span class="line"><span class="comment"># always start from leftmost</span></span><br><span class="line">l=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; n):</span><br><span class="line">r = <span class="built_in">min</span>(l+(width*<span class="number">2</span>-<span class="number">1</span>), n-<span class="number">1</span>)</span><br><span class="line">m = <span class="built_in">min</span>(l+width-<span class="number">1</span>,n-<span class="number">1</span>)</span><br><span class="line"><span class="comment"># final merge should consider</span></span><br><span class="line"><span class="comment"># unmerged sublist if input arr</span></span><br><span class="line"><span class="comment"># size is not power of 2</span></span><br><span class="line">merge(a, l, m, r)</span><br><span class="line">l += width*<span class="number">2</span></span><br><span class="line"><span class="comment"># Increasing sub array size by powers of 2</span></span><br><span class="line">width *= <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"><span class="comment"># Merge Function</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">a, l, m, r</span>):</span><br><span class="line">n1 = m - l + <span class="number">1</span></span><br><span class="line">n2 = r - m</span><br><span class="line">L = [<span class="number">0</span>] * n1</span><br><span class="line">R = [<span class="number">0</span>] * n2</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n1):</span><br><span class="line">L[i] = a[l + i]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n2):</span><br><span class="line">R[i] = a[m + i + <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">i, j, k = <span class="number">0</span>, <span class="number">0</span>, l</span><br><span class="line"><span class="keyword">while</span> i &lt; n1 <span class="keyword">and</span> j &lt; n2:</span><br><span class="line"><span class="keyword">if</span> L[i] &lt;= R[j]:</span><br><span class="line">a[k] = L[i]</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">a[k] = R[j]</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line">k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> i &lt; n1:</span><br><span class="line">a[k] = L[i]</span><br><span class="line">i += <span class="number">1</span></span><br><span class="line">k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> j &lt; n2:</span><br><span class="line">a[k] = R[j]</span><br><span class="line">j += <span class="number">1</span></span><br><span class="line">k += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Driver code</span></span><br><span class="line">a = [-<span class="number">74</span>,<span class="number">48</span>,-<span class="number">20</span>,<span class="number">2</span>,<span class="number">10</span>,-<span class="number">84</span>,-<span class="number">5</span>,-<span class="number">9</span>,<span class="number">11</span>,-<span class="number">24</span>,-<span class="number">91</span>,<span class="number">2</span>,-<span class="number">71</span>,<span class="number">64</span>,<span class="number">63</span>,<span class="number">80</span>,<span class="number">28</span>,-<span class="number">30</span>,-<span class="number">58</span>,-<span class="number">11</span>,-<span class="number">44</span>,-<span class="number">87</span>,-<span class="number">22</span>,<span class="number">54</span>,-<span class="number">74</span>,-<span class="number">10</span>,-<span class="number">55</span>,-<span class="number">28</span>,-<span class="number">46</span>,<span class="number">29</span>,<span class="number">10</span>,<span class="number">50</span>,-<span class="number">72</span>,<span class="number">34</span>,<span class="number">26</span>,<span class="number">25</span>,<span class="number">8</span>,<span class="number">51</span>,<span class="number">13</span>,<span class="number">30</span>,<span class="number">35</span>,-<span class="number">8</span>,<span class="number">50</span>,<span class="number">65</span>,-<span class="number">6</span>,<span class="number">16</span>,-<span class="number">2</span>,<span class="number">21</span>,-<span class="number">78</span>,<span class="number">35</span>,-<span class="number">13</span>,<span class="number">14</span>,<span class="number">23</span>,-<span class="number">3</span>,<span class="number">26</span>,-<span class="number">90</span>,<span class="number">86</span>,<span class="number">25</span>,-<span class="number">56</span>,<span class="number">91</span>,-<span class="number">13</span>,<span class="number">92</span>,-<span class="number">25</span>,<span class="number">37</span>,<span class="number">57</span>,-<span class="number">20</span>,-<span class="number">69</span>,<span class="number">98</span>,<span class="number">95</span>,<span class="number">45</span>,<span class="number">47</span>,<span class="number">29</span>,<span class="number">86</span>,-<span class="number">28</span>,<span class="number">73</span>,-<span class="number">44</span>,-<span class="number">46</span>,<span class="number">65</span>,-<span class="number">84</span>,-<span class="number">96</span>,-<span class="number">24</span>,-<span class="number">12</span>,<span class="number">72</span>,-<span class="number">68</span>,<span class="number">93</span>,<span class="number">57</span>,<span class="number">92</span>,<span class="number">52</span>,-<span class="number">45</span>,-<span class="number">2</span>,<span class="number">85</span>,-<span class="number">63</span>,<span class="number">56</span>,<span class="number">55</span>,<span class="number">12</span>,-<span class="number">85</span>,<span class="number">77</span>,-<span class="number">39</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Given array is &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line">mergeSort(a)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Sorted array is &quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Contributed by Madhur Chhangani [RCOEM]</span></span><br><span class="line"><span class="comment"># corrected and improved by @mahee96</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由此可以明白为什么我们需要递归，迭代法简直看着头大。代码来源于网络，我也没研究迭代法。。</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorting - Shell Sort</title>
      <link href="/Blog/2022/07/25/shellSort/"/>
      <url>/Blog/2022/07/25/shellSort/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Reference: <a href="https://www.cnblogs.com/jsgnadsj/p/3458054.html">算法学习记录-希尔排序</a></p></blockquote><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>常见的基础排序算法如冒泡排序，插入排序和选择排序都是$O(n^2)$ 的算法， 为了加速排序，早期一些优化算法将其加速到$O(nlogn)$. 希尔既是如此。直接插入排序在本身逆序存在较少的情况下效率很高，如果逆序较多时则不理想。这是因为如果一个最大的元素在第一位，直接插入需要所有元素都向右边移动一位。</p><p>能否减少这样的位移呢？ 答案是可以的：希尔排序算法会设置一个间隔，同一间隔的所有元素被设置成一组，在组内进行插入排序从而实现了大步排序。然后逐步缩小间隔到1,此时希尔排序就变成了直接插入排序。</p><p>故而，希尔排序可以看成家了预处理的直接插入排序，或者多步长的插入排序。那么如何选择步长序列呢？ 希尔最先提出的是不断二分，但是这种情况会出现极端情况造成希尔排序比直接插入还要慢：当所有预处理并没有任何改变原序列的情况。为了避免，步长序列通常选择互质（既除了1没有别的公约数），然后保证最后一个步长为1。这样可以防止预处理出现盲区而没做任何优化。一个常见的步长序列是$3n+1$,$n$从1开始。</p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><ol><li>Select the increment sequence $t_1, t_2, …, t_k$, where $t_k&#x3D;1$;</li><li>Do insertion sort with the increment foot long $t_1$</li><li>Repeat step 2 with the decreasing foot long until $t_k$</li></ol><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shellSort</span>(<span class="params">arr</span>):</span><br><span class="line">  <span class="comment"># select increemnt sequence</span></span><br><span class="line">  gap = <span class="number">1</span></span><br><span class="line">  N = <span class="built_in">len</span>(arr)</span><br><span class="line">  <span class="keyword">while</span>(gap &lt; N/<span class="number">3</span>):</span><br><span class="line">    gap = gap*<span class="number">3</span>+<span class="number">1</span></span><br><span class="line">  <span class="comment"># start insertation</span></span><br><span class="line">  <span class="keyword">while</span> gap&gt;<span class="number">0</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(gap,N):</span><br><span class="line">      temp = arr[i]</span><br><span class="line">      j = i - gap</span><br><span class="line">      <span class="keyword">while</span> j&gt;=<span class="number">0</span> <span class="keyword">and</span> arr[j]&gt;temp:</span><br><span class="line">        arr[j+gap] = arr[j]</span><br><span class="line">        j-=gap</span><br><span class="line">      arr[j+gap] = temp</span><br><span class="line">    gap = gap//<span class="number">3</span></span><br><span class="line">  <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorting - Insertion Sort</title>
      <link href="/Blog/2022/07/25/insertionSort/"/>
      <url>/Blog/2022/07/25/insertionSort/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>插入排序跟打牌一样，没抽到一张新牌，与前面排好序的拍对比，插入到相应位置即可。常见的插入方法即把新牌从后往前冒泡。时间复杂度为$O(n^2)$.</p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><ol><li>把第一个数字当成已经排列完毕，直接从第二个元素开始往前冒泡。</li><li>如上从第二个元素到结尾，将新元素从已排序序列的尾段往前冒泡</li></ol><h1 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h1><p><img src="/Blog/images/insertionSort.gif" alt="GIF"></p><h1 id="Python-code"><a href="#Python-code" class="headerlink" title="Python code"></a>Python code</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insertionSort</span>(<span class="params">arr</span>):</span><br><span class="line">  N = <span class="built_in">len</span>(arr)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,<span class="number">0</span>,-<span class="number">1</span>):</span><br><span class="line">      <span class="keyword">if</span> arr[j]&lt;arr[j-<span class="number">1</span>]:</span><br><span class="line">        arr[j],arr[j-<span class="number">1</span>] = arr[j-<span class="number">1</span>], arr[j]</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorting - Selection Sort</title>
      <link href="/Blog/2022/07/25/selectionSort/"/>
      <url>/Blog/2022/07/25/selectionSort/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>选择排序简单直观，无论什么数据进去都是$O(n^2)$ 的时间复杂度。所以用的时候数据规模越小越好。唯一的好处是不占用额外的内存空间。</p><h1 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h1><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>在从剩余未排序元素中寻找最小（大）元素，然后放到已排序序列的末尾</li><li>重复第二步，直到排序完毕。</li></ol><h1 id="动图演示"><a href="#动图演示" class="headerlink" title="动图演示"></a>动图演示</h1><p><img src="/Blog/images/selectionSort.gif" alt="GIF"></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 无非是从地一个到倒数第二个位置，逐一在后面未排序的数列里面选最小元素而已</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">selectionSort</span>(<span class="params">arr</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N-<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">min</span> = arr[i]</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, N):</span><br><span class="line">            <span class="keyword">if</span> arr[j]&lt;<span class="built_in">min</span>:</span><br><span class="line">                <span class="built_in">min</span> = arr[j]</span><br><span class="line">                arr[i],arr[j] = arr[j], arr[i]</span><br><span class="line">    <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorting - Bubble Sort</title>
      <link href="/Blog/2022/07/25/bubbleSort/"/>
      <url>/Blog/2022/07/25/bubbleSort/</url>
      
        <content type="html"><![CDATA[<h1 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h1><p>The method is easy to understand: it repeatedly iterate the array and compares the coherent two elements. If the order of the two elements conflicts with the requirement, switch their positions. The name is because the maximum values will gradually bubble out to the end of the array.</p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><ol><li>Compare the neighbor elements, if the first element is greater, switch the position.</li><li>Continue the step 1 until the maximum element bubbles to the end, this element is considered sorted and will not join the comparing any more.</li><li>Repeated step 1 and step 2 and the number of sorted elements at the end increments by 1 every time, until all elements are sorted</li></ol><h1 id="GIF"><a href="#GIF" class="headerlink" title="GIF"></a>GIF</h1><p><img src="/Blog/images/bubbleSort.gif" alt="GIF"></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>):</span><br><span class="line">  N = <span class="built_in">len</span>(arr)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-i):</span><br><span class="line">      <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">        arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j] <span class="comment"># switch</span></span><br><span class="line">  <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorting - Overview</title>
      <link href="/Blog/2022/07/24/Sorting/Sorting/"/>
      <url>/Blog/2022/07/24/Sorting/Sorting/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Reference：[排序算法]（<a href="https://github.com/hustcc/JS-Sorting-Algorithm.git%EF%BC%89">https://github.com/hustcc/JS-Sorting-Algorithm.git）</a></p></blockquote><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>排序算法是数据结构和算法中最基本的算法之一，最常碰见的包括：冒泡排序，选择排序，插入排序，归并排序，快速排序，堆排序，基数排序，希尔排序等。 用一张图概括：</p><img src="/Blog/images/sort.png" class="[sort]" title="[3][3] " alt="Sort Algorithms"><h1 id="Time-Complexity"><a href="#Time-Complexity" class="headerlink" title="Time Complexity"></a>Time Complexity</h1><ol><li>$O(n^2)$: Bubble Sort, Selection Sort and Insertion Sort.</li><li>$O(nlog_2n)$: Quick Sort, Heap Sort and Merge Sort</li><li>$O(n^{1+{\theta}} )$ where ${\theta} \in [0,1]$ between 0 and 1: Shell Sort</li><li>$O(n)$ Radix Sort and Bucket Sort</li></ol><h1 id="Stability"><a href="#Stability" class="headerlink" title="Stability"></a>Stability</h1><ul><li>Stable: Bubble Sort, Insertion Sort, Merge Sort and Radix Sort</li><li>Unstable: Selection Sort, Quick Sort, Shell Sort, Heap Sort</li></ul><h1 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h1><a href="/Blog/2022/07/25/bubbleSort/" title="1.冒泡排序">1.冒泡排序</a><a href="/Blog/2022/07/25/selectionSort/" title="2.选择排序">2.选择排序</a><a href="/Blog/2022/07/25/insertionSort/" title="3.插入排序">3.插入排序</a><a href="/Blog/2022/07/25/shellSort/" title="4.希尔排序">4.希尔排序</a><a href="/Blog/2022/07/25/mergeSort/" title="5.归并排序">5.归并排序</a><a href="/Blog/2022/07/27/QuickSort/" title="6.快速排序">6.快速排序</a><a href="/Blog/2022/07/27/HeapSort/" title="7.堆排序">7.堆排序</a><a href="/Blog/2022/08/12/bucketSort/" title="8.桶排序">8.桶排序</a>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL- Search(2)</title>
      <link href="/Blog/2022/07/23/MySQL/MySQL-Search/"/>
      <url>/Blog/2022/07/23/MySQL/MySQL-Search/</url>
      
        <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>This article lists the most common key words for the entry searching in MySQL table, covering from conditional language, to logical operators.</p><h2 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h2><p>If you want to print of the entries with unique columns:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">DISTINCT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column_name <span class="keyword">FROM</span> tb_name;</span><br></pre></td></tr></table></figure><p>Ordering the items according specific column:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column_name</span><br><span class="line"><span class="keyword">FROM</span> tb_name  </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name1;</span><br></pre></td></tr></table></figure><p>If you only want part of the entries:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column_name</span><br><span class="line"><span class="keyword">FROM</span> tb_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name2 <span class="keyword">DESC</span><span class="operator">/</span><span class="keyword">ASC</span> LIMIT <span class="operator">&lt;</span>NUM_STATR, NUM_OF_ROWS<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>To perform vague searching, use LIKE with ‘%’:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> <span class="string">&#x27;%Mike%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>For searching that specifies the length of the string, use underscore ‘_’:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> stock_quantity <span class="keyword">LIKE</span> <span class="string">&#x27;____&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="Aggregate-Functions"><a href="#Aggregate-Functions" class="headerlink" title="Aggregate Functions"></a>Aggregate Functions</h2><p>To count the number of entries, use COUNT:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> author_lname <span class="operator">=</span><span class="string">&#x27;Gaiman&#x27;</span>;</span><br></pre></td></tr></table></figure><p>Sometime if we want to group the entries according to to part of their property, we use GROUP BY:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, author_lname, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> books <span class="keyword">GROUP</span> <span class="keyword">BY</span> author_lname,author_fname;</span><br></pre></td></tr></table></figure><p>GROUP BY often is combined with other operations to this specific group.</p><p>To sum up and average the numbers, use SUM:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(released_year)</span><br><span class="line"><span class="keyword">FROM</span> books;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(released_year)</span><br><span class="line"><span class="keyword">FROM</span> books;</span><br></pre></td></tr></table></figure><h2 id="Date-and-Time"><a href="#Date-and-Time" class="headerlink" title="Date and Time"></a>Date and Time</h2><p>The most commonly used:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">## These <span class="keyword">no</span> need args</span><br><span class="line">CURDATE();</span><br><span class="line">CURTIME();</span><br><span class="line">NOW();</span><br><span class="line">## These <span class="keyword">are</span> <span class="keyword">for</span> extracting</span><br><span class="line"><span class="keyword">DAY</span>(DateType);</span><br><span class="line">DAYOFNAME(DateType); ## <span class="keyword">return</span> Monday, ..</span><br><span class="line">DAYOFWEEK(DateType); ## <span class="keyword">return</span> the index <span class="keyword">of</span> the <span class="keyword">day</span></span><br><span class="line">DAYOFYEAR(DateType); <span class="keyword">return</span> index</span><br><span class="line"><span class="keyword">HOUR</span>();</span><br><span class="line"><span class="keyword">MINUTE</span>();</span><br></pre></td></tr></table></figure><p>A more convenient function is DATE_FORMAT():</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(birthday, <span class="string">&#x27;%W&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> people;</span><br></pre></td></tr></table></figure><p>W means the Monday,etc. For more indicators, check the official manual.</p><p>$TIMESTAMP$ is a specific type for time data:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">timestamp</span> <span class="keyword">DEFAULT</span> NOW() <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span><span class="operator">/</span>NOW();</span><br></pre></td></tr></table></figure><h2 id="Logical-Operators"><a href="#Logical-Operators" class="headerlink" title="Logical Operators"></a>Logical Operators</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">## <span class="keyword">not</span> equal</span><br><span class="line"><span class="operator">!=</span> 或者 <span class="keyword">NOT</span>;</span><br><span class="line">## greater<span class="operator">/</span>smaller<span class="operator">/</span>equal</span><br><span class="line"><span class="operator">&gt;</span> <span class="operator">&lt;</span>  <span class="operator">=</span>;</span><br><span class="line"><span class="keyword">AND</span> 或者 <span class="operator">&amp;&amp;</span>;</span><br><span class="line"><span class="keyword">OR</span> 或者 <span class="operator">||</span>;</span><br><span class="line"><span class="keyword">BETWEEN</span> x <span class="keyword">AND</span> y;</span><br><span class="line"><span class="keyword">IN</span> 和 <span class="keyword">NOT</span> <span class="keyword">IN</span>;</span><br><span class="line">## modulo <span class="operator">%</span></span><br><span class="line"><span class="keyword">SELECT</span> title,author_lname <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> author_lname <span class="keyword">IN</span>(<span class="string">&#x27;CHARLES&#x27;</span>,<span class="string">&#x27;GAIMAN&#x27;</span>) <span class="keyword">and</span> released_year <span class="operator">%</span> <span class="number">2</span><span class="operator">!=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>A little complex is case statement:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, released_year,</span><br><span class="line">  <span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> released_year<span class="operator">&gt;=</span><span class="number">2000</span> <span class="keyword">THEN</span> <span class="string">&#x27;modern LIT&#x27;</span></span><br><span class="line">    <span class="keyword">WHEN</span> condition2 <span class="keyword">THEN</span> result2</span><br><span class="line">    <span class="keyword">ELSE</span> result2</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">&#x27;genre&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> books;</span><br></pre></td></tr></table></figure><p>If we want to group the entries by the authors and get the number of their books or book:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, author_lname,</span><br><span class="line">  <span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">=</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">&#x27;1 book&#x27;</span></span><br><span class="line">    <span class="keyword">ELSE</span> CONCAT(<span class="built_in">COUNT</span>(<span class="operator">*</span>), <span class="string">&#x27; books&#x27;</span>)</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">&#x27;counts&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> books</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> author_lname;</span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>This article lists the basic operation within a table with conditional commands. In future article, more complex commands dealing with inter-table relationships will be summarized.</p>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xv6 Operating System Organization</title>
      <link href="/Blog/2022/07/18/Xv6/Organization/"/>
      <url>/Blog/2022/07/18/Xv6/Organization/</url>
      
        <content type="html"><![CDATA[<h1 id="Operating-System-Organization"><a href="#Operating-System-Organization" class="headerlink" title="Operating System Organization"></a>Operating System Organization</h1><blockquote><p>参考  <a href="https://github.com/mit-pdos/xv6-riscv-book">xv6-riscv-book</a> Chapter 2 Operating system organization</p></blockquote><p>Three requirements for OS:</p><ul><li>multiplexing</li><li>isolation</li><li>interaction</li></ul><h2 id="Abstracting-physical-resources"><a href="#Abstracting-physical-resources" class="headerlink" title="Abstracting physical resources"></a>Abstracting physical resources</h2><blockquote><p>Transparency: simplifies interaction</p></blockquote><ul><li>Abstract the resources into services</li><li>Applications don’t have to be aware of time sharing</li><li>Allows the OS to decide the usage of memory</li></ul><h2 id="User-mode-supervisor-mode-and-system-calls"><a href="#User-mode-supervisor-mode-and-system-calls" class="headerlink" title="User mode, supervisor mode, and system calls"></a>User mode, supervisor mode, and system calls</h2><img src="/Blog/images/kernel.png" class="[kernel]" title="[3][3] " alt="kernel"><h2 id="Kernel-organization"><a href="#Kernel-organization" class="headerlink" title="Kernel organization"></a>Kernel organization</h2><table><thead><tr><th>Organization</th><th>Description</th><th>Upside</th><th>Downside</th></tr></thead><tbody><tr><td>monolithic kernel</td><td>the entire OS resides in the kernel with full privilege</td><td>convenient, <br>easier for different parts of the OS to cooperate</td><td>complex interfaces, <br>easy to make a mistake, <br>a mistake is fatal</td></tr><tr><td>microkernel</td><td>minimize the code that runs in supervisor mode, <br>execute the bulk of the OS in user mode</td><td>reduce the risk of mistakes in the kernel</td><td></td></tr></tbody></table><img src="/Blog/images/microkernel.png" class="[microkernel]" title="[3][3] " alt="microkernel"><p>(NOTE&gt; OS services running as processes are called servers)</p><h2 id="Xv6-organization"><a href="#Xv6-organization" class="headerlink" title="Xv6 organization"></a>Xv6 organization</h2><p>Xv6 kernel source files:</p><table><thead><tr><th>File</th><th>Description</th></tr></thead><tbody><tr><td>bio.c</td><td>Disk block cache for the file system.</td></tr><tr><td>console.c</td><td>Connect to the user keyboard and screen.</td></tr><tr><td>entry.S</td><td>Very first boot instructions.</td></tr><tr><td>exec.c</td><td>exec() system call.</td></tr><tr><td>file.c</td><td>File descriptor support.</td></tr><tr><td>fs.c</td><td>File system.</td></tr><tr><td>kalloc.c</td><td>Physical page allocator.</td></tr><tr><td>kernelvec.S</td><td>Handle traps from kernel, and timer interrupts.</td></tr><tr><td>log.c</td><td>File system logging and crash recovery.</td></tr><tr><td>main.c</td><td>Control initialization of other modules during boot.</td></tr><tr><td>pipe.c</td><td>Pipes.</td></tr><tr><td>plic.c</td><td>RISC-V interrupt controller.</td></tr><tr><td>printf.c</td><td>Formatted output to the console.</td></tr><tr><td>proc.c</td><td>Processes and scheduling.</td></tr><tr><td>sleeplock.c</td><td>Locks that yield the CPU.</td></tr><tr><td>spinlock.c</td><td>Locks that don’t yield the CPU.</td></tr><tr><td>start.c</td><td>Early machine-mode boot code.</td></tr><tr><td>string.c</td><td>C string and byte-array library.</td></tr><tr><td>swtch.S</td><td>Thread switching.</td></tr><tr><td>syscall.c</td><td>Dispatch system calls to handling function.</td></tr><tr><td>sysfile.c</td><td>File-related system calls.</td></tr><tr><td>sysproc.c</td><td>Process-related system calls.</td></tr><tr><td>trampoline.S</td><td>Assembly code to switch between user and kernel.</td></tr><tr><td>trap.c C</td><td>code to handle and return from traps and interrupts.</td></tr><tr><td>uart.c</td><td>Serial-port console device driver.</td></tr><tr><td>virtio_disk.c</td><td>Disk device driver.</td></tr><tr><td>vm.c</td><td>Manage page tables and address spaces.</td></tr></tbody></table><p>(From: <code>pbpaste | awk &#39;&#123; printf(&quot;| %s |&quot;, $1); for (i=2; i&lt;=NF; i++) printf(&quot; %s&quot;, $i); printf(&quot; |\n&quot;); &#125;&#39; | pbcopy</code>)</p><p>The inter-module interfaces are defined in <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/defs.h">kernel&#x2F;defs.h</a>.</p><h2 id="Process-overview"><a href="#Process-overview" class="headerlink" title="Process overview"></a>Process overview</h2><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><p>The unit of isolation: a <em>process</em>: an illusion to a program that it has its own private machine (private memory, CPU, file descriptors, etc.). Process is defined as <code>struct proc</code> (<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/proc.h#L86">kernel&#x2F;proc.h:86</a>).</p><ul><li><code>p-&gt;state</code>: whether the process is allocated, ready to run, running, waiting for I&#x2F;O, or exiting:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> &#123;</span> UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br></pre></td></tr></table></figure><ul><li><code>p-&gt;pagetable</code>: holds the process’s page table.</li></ul><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><p><em>Thread</em> (of execution): executes the process’s instructions.</p><p>A thread can be suspended and later resumed.</p><p>Threads can “block” in the kernel to wait for I&#x2F;O, and resume where it left off when the I&#x2F;O has finished.</p><h3 id="Virtual-address"><a href="#Virtual-address" class="headerlink" title="Virtual address"></a>Virtual address</h3><p>Virtual address: Isolation of memory:  <code>virtual address -- page tables --&gt; physical address</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MAXVA</span><br><span class="line">↑    trampoline</span><br><span class="line">|    trapframe</span><br><span class="line">|    Heap</span><br><span class="line">|    Stack (user stack)</span><br><span class="line">|    Global Variables (text and data)</span><br><span class="line">|    Instructions</span><br><span class="line">0</span><br></pre></td></tr></table></figure><ul><li>VA is starting at zero</li><li>MAXVA (the maximum virtual address) defined in <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/riscv.h#L348"> kernel&#x2F;riscv.h:348</a>: Xv6 uses 38 bits to look up virtual addresses in page tables: $\textrm{MAXVA}&#x3D;2^{38}-1&#x3D;\textrm{0x3fffffffff}$</li><li>Each process has two stacks: user stack &amp; kernel stack (<code>p-&gt;kstack</code>, for a system call or interrupt, separate and protected from user code).</li></ul><h3 id="System-call"><a href="#System-call" class="headerlink" title="System call"></a>System call</h3><p><code>ecall</code>: a RISC-V instruction to make a system call:</p><ol><li>raises hardware privilege level</li><li>change PC to a kernel-defined entry point, switches to a kernel stack</li><li>executes the kernel instructions</li><li>(system call completes) switches back to the user stack</li><li>returns to user space by calling the <code>sret</code> instruction (lowers the hardware privilege level)</li><li>resumes executing user instructions just after the system call instruction</li></ol><h2 id="Starting-xv6-and-the-first-process"><a href="#Starting-xv6-and-the-first-process" class="headerlink" title="Starting xv6 and the first process"></a>Starting xv6 and the first process</h2><ol><li>RISC-V computer powers on, self initializes</li><li>runs a boot loader (stored in ROM): loads the xv6 kernel into memory at physical address 0x80000000 (range 0x0:0x80000000 contains I&#x2F;O devices)</li><li>(in machine mode) executes xv6 starting at <code>_entry</code> (<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/entry.S#L6">kernel&#x2F;entry.S:6</a>), sets up a stack (<code>stack0</code>) for C code (<code>sp = stack0 + (hartid * 4096)</code>)</li><li><code>_entry</code> calls into C code: function  <code>start</code> (<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/start.c#L11">kernel&#x2F;start.c:11</a>)</li><li><code>start</code>  performs configuration(page-table, interrupts…)</li><li>switches to supervisor mode, PC change to <code>main</code> (<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/main.c#L11">kernel&#x2F;main.c:11</a>)</li><li><code>main</code> initializes several devices and subsystems</li><li>creates the first process by calling userinit (<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/proc.c#L212">kernel&#x2F;proc.c:212</a>)</li><li>run <code>initcode.S</code> (<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/initcode.S#L1">user&#x2F;initcode.S:1</a>), do <code>exec(&quot;/init&quot;)</code></li><li><code>init</code>  (<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/init.c#L15">user&#x2F;init.c:15</a>) creates a console device file, opens it as file descriptors 0, 1, and 2</li><li>starts a shell on the console</li><li>The system is up.</li></ol><hr><p>EOF</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// By CDFMLR 2021-02-27</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;See you.\n&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Queue for Moving Window</title>
      <link href="/Blog/2022/07/16/Algorithms/MovingWindow/"/>
      <url>/Blog/2022/07/16/Algorithms/MovingWindow/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Moving window is the type of questions that has a specified size $k$ of window skim across an array, performing filtering on the numbers such as averaging or finding local maximum value. It is straightforward to update the maximal value when a new number is added to the array iteratively whereas removing a value at the same time complex the problem.</p><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>You are given an array of integer nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p><p>Example:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">Output: [3,3,5,5,6,7]</span><br><span class="line">Explanation:</span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><h2 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h2><p>The first idea of solving this problem is Brute Force which has time complexity as $O(nk)$ and $O(1)$. In this case repetitive comparing is performed unless the hopping size is smaller than 3 (Think about that at step $i$, the comparison between $nums[i+1]$ and $nums[]$ will be conducted again at iteration $i+1$).</p><p>Two data structures are good solutions to this problem as they allow easy maximal value finding when element-wise updating happens: priority queue (heap) and monotonic queue. Python provides packages for them both(heapq &amp; collections.deque) for use but it is good to understand the working mechanisms. This note will go through both structures in a bottom-up way.</p><h1 id="Priority-queue"><a href="#Priority-queue" class="headerlink" title="Priority queue"></a>Priority queue</h1><p>Priority queue acts like a queue in that you dequeue an item by removing it from the front. However, in a priority queue the logical order of items inside a queue is determined by their priority. Thus when a new item joins the priority queue, it may move its way up until the front, which is a useful property for many applications such as sorting problems.</p><h2 id="Complete-Binary-Tree"><a href="#Complete-Binary-Tree" class="headerlink" title="Complete Binary Tree"></a>Complete Binary Tree</h2><p>Although a priority queue can be implemented using $list$ with sorting functions, inserting into a list is $O(n)$ and sorting is $O(nlogn)$. Meanwhile, a binary heap allows both enqueue and dequeue items in $O(logn)$ hence is usually more popular.</p><p>It is worth noting that a binary heap diagram looks like a tree but the actual structure is an array(usually a list in Python). This is because the index of its elements follow strictly the structure of a $complete binary tree$, where all levels except the deepest are fully filled and the nodes of the lowest are filled from left to right. An extra property for heap is either the key stored in each node is greater&#x2F;equal than the keys in the node’s children (Max heap) or small&#x2F;equal(Min heap).</p><p>The advantage of a complete binary tree is that it ensures a index relation between a parent node and all its children nodes: for any parent node $i$, it’s left node and right node (if exists) are at the index of $2i+1$ and $2i+2$. Reversely, for any node, its parent node’s index is $(i-1)&#x2F;&#x2F;2$(if i&#x3D;0 is the root node). This property make it very convenient for traversing tree nodes following the relations.</p><p>Now the issue is to maintain the property in the queue and dequeue operations. After inserting a new element, for example, it compare the value of the new element $nums[i]$ with its parent node nums[(i-1)&#x2F;&#x2F;2] and if the relation violates the property, they switch position. The comparison and switching keep happening until the property is restored:</p><p><img src="http://www.openbookproject.net/books/pythonds/_images/percUp.png" alt="Adding element"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># restore the property after a new element is inserted at the ith --- max heap</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perc_up</span>(<span class="params">self, i</span>):</span><br><span class="line">  <span class="keyword">while</span> (i-<span class="number">1</span>) // <span class="number">2</span> &gt; <span class="number">0</span>: <span class="comment"># Assuming the tree and the array share the index and root index i=0</span></span><br><span class="line">    <span class="keyword">if</span> self.heap_list[i] &gt; self.heap_list[(i-<span class="number">1</span>)//<span class="number">2</span>]:</span><br><span class="line">       <span class="comment"># The new element larger than its parent</span></span><br><span class="line">       tmp = self.heap_list[(i-<span class="number">1</span>)//<span class="number">2</span>]</span><br><span class="line">       self.heap_list[(i-<span class="number">1</span>)//<span class="number">2</span>] = self.heap_list[i]</span><br><span class="line">       self.heap_list[i] = tmp</span><br><span class="line">       i = (i-<span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self,k</span>):</span><br><span class="line">  self.heap_list.append(k)</span><br><span class="line">  self.current_size = self.current_size+<span class="number">1</span></span><br><span class="line">  self.perc_up(self.current_size)</span><br></pre></td></tr></table></figure><p>Removing the head(maximum) of the heap follows the steps:</p><ul><li>Remove the root node</li><li>pop out the end of the queue and replace as the root</li><li>compare the value of the new root with its children and switch its position with the child node with greater value.</li><li>continue the previous step until the order is restored.</li></ul><p><img src="http://www.openbookproject.net/books/pythonds/_images/percDown.png" alt="dequeue"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># restore the property after removing the head</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perc_down</span>(<span class="params">self, i</span>):</span><br><span class="line">  <span class="comment">#The i is not necessarily the root nodes, root node index is 0</span></span><br><span class="line">  <span class="keyword">while</span> <span class="number">2</span>*i+<span class="number">1</span> &lt;= self.current_size:</span><br><span class="line">    mc = self.max_child(i)</span><br><span class="line">    <span class="keyword">if</span> self.heap_list[i.] &lt; self.heap_list[mc]:</span><br><span class="line">      tmp = self.heap_list[mc]</span><br><span class="line">      self.heap_list[mc] = self.heap_list[i]</span><br><span class="line">      self.heap_list[i] = tmp</span><br><span class="line">    i = mc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max_child</span>(<span class="params">self, i</span>):</span><br><span class="line">  <span class="keyword">if</span> i*<span class="number">2</span>+<span class="number">2</span>&gt; self.current_size:</span><br><span class="line">    <span class="keyword">return</span> i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> i*<span class="number">2</span>+<span class="number">1</span> <span class="keyword">if</span> self.heap_list[i*<span class="number">2</span>+<span class="number">1</span>]&gt;self.heap_list[i*<span class="number">2</span>+<span class="number">2</span>] <span class="keyword">else</span> i*<span class="number">2</span>+<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">del_head</span>(<span class="params">self</span>):</span><br><span class="line">  ret = self.heap_list[<span class="number">0</span>]</span><br><span class="line">  self.heap_list[<span class="number">0</span>] = self.heap_list[-<span class="number">1</span>]</span><br><span class="line">  self.current_size -=<span class="number">1</span></span><br><span class="line">  self.heap_list.pop()</span><br><span class="line">  self.perc_down(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>A powerful property of heap is for any element in the array, it only takes $logn$ times (the level numbers) of comparing and switching to ensure it is smaller&#x2F;greater than its parent node. Applied to every nodes, the time complexity of heap sorting is therefore $nlogn$ to an array.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Python provides $heapq$, which does the order restoring as above for us. We only need to take care of the FIFO tasks. As the default heapq in Python is minimum heap, we can create a new array with -nums[i] elements instead. The implementation is as below:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 注意 Python 默认的优先队列是小根堆</span></span><br><span class="line">        q = [(-nums[i], i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)] <span class="comment"># value and index</span></span><br><span class="line">        heapq.heapify(q) <span class="comment">#Transform a list into a heap, in-place, in linear time</span></span><br><span class="line"></span><br><span class="line">        ans = [-q[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">            heapq.heappush(q, (-nums[i], i)) <span class="comment"># Push while maintaining the heap invariant</span></span><br><span class="line">            <span class="keyword">while</span> q[<span class="number">0</span>][<span class="number">1</span>] &lt;= i - k:</span><br><span class="line">                heapq.heappop(q) <span class="comment"># pop and return the smallest item from the heap</span></span><br><span class="line">            ans.append(-q[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>The time complexity of solution is $O((n-k)*logn)$ because the worst case is k&gt;n and pushing and poping an element are both $O(logn)$ (Actually from maintaining the heap invariant). Space complexity is $O(n)$.</p><h1 id="Monotonic-dequeue"><a href="#Monotonic-dequeue" class="headerlink" title="Monotonic dequeue"></a>Monotonic dequeue</h1><p>Removing the head of a list is $O(n)$ because the index of all elements need to shift a step backward. Dequeue is therefore implemented for convenience operations on both ends(operating on the middle is still $O(n)$).</p><p>Now re-think the problem: if we keeps a monotonically decreasing stack at iteration $i$, and at the step $i+1$ we compare the new element with the last element in the stack. If the new element is larger, the last element in the stack is no longer useful: if it cannot win the current iteration, it definetely will not win the next. So we can safely pop it out and replace it with the new element. Continue until the new element can be pushed as the tail of the stack then check if the head element is still in the window from the index. If it is still in, it is return as the answer of this round. If not, pop the head out and return the new head. To speed up the head popping, dequeue is used instead of stack.</p><p>Example:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7]</span><br><span class="line"></span><br><span class="line">解释过程中队列中都是具体的值，方便理解，具体见代码。</span><br><span class="line">初始状态：L=R=0,队列:&#123;&#125;</span><br><span class="line">i=0,nums[0]=1。队列为空,直接加入。队列：&#123;1&#125;</span><br><span class="line">i=1,nums[1]=3。队尾值为1，3&gt;1，弹出队尾值，加入3。队列：&#123;3&#125;</span><br><span class="line">i=2,nums[2]=-1。队尾值为3，-1&lt;3，直接加入。队列：&#123;3,-1&#125;。此时窗口已经形成，L=0,R=2，result=[3]</span><br><span class="line">i=3,nums[3]=-3。队尾值为-1，-3&lt;-1，直接加入。队列：&#123;3,-1,-3&#125;。队首3对应的下标为1，L=1,R=3，有效。result=[3,3]</span><br><span class="line">i=4,nums[4]=5。队尾值为-3，5&gt;-3，依次弹出后加入。队列：&#123;5&#125;。此时L=2,R=4，有效。result=[3,3,5]</span><br><span class="line">i=5,nums[5]=3。队尾值为5，3&lt;5，直接加入。队列：&#123;5,3&#125;。此时L=3,R=5，有效。result=[3,3,5,5]</span><br><span class="line">i=6,nums[6]=6。队尾值为3，6&gt;3，依次弹出后加入。队列：&#123;6&#125;。此时L=4,R=6，有效。result=[3,3,5,5,6]</span><br><span class="line">i=7,nums[7]=7。队尾值为6，7&gt;6，弹出队尾值后加入。队列：&#123;7&#125;。此时L=5,R=7，有效。result=[3,3,5,5,6,7]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>And the code:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单调双端队列 O(n)，O（k）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        res = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums)-k+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment">#保证从大到小 如果前面数小则需要依次弹出，直至满足要求</span></span><br><span class="line">            <span class="keyword">while</span> queue <span class="keyword">and</span> nums[queue[-<span class="number">1</span>]] &lt;= nums[i]:</span><br><span class="line">                queue.pop()</span><br><span class="line">            queue.append(i)</span><br><span class="line">            <span class="comment">#判断队首值是否有效</span></span><br><span class="line">            <span class="keyword">if</span> queue[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">                queue.popleft()</span><br><span class="line">            <span class="comment">#当窗口长度为k时 保存当前窗口中最大值</span></span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &gt;= k:</span><br><span class="line">                res[i+<span class="number">1</span>-k] = nums[queue[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>The time complexity is $O(n)$ and the space complexity is $O(k)$.</p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Monotonic Stack</title>
      <link href="/Blog/2022/07/15/Algorithms/MonotonicStack/"/>
      <url>/Blog/2022/07/15/Algorithms/MonotonicStack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考: <a href="https://leetcode.cn/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/">Trapping Rain Water</a><br><a href="https://leetcode.cn/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/">Daily Temperatures</a><br><a href="https://leetcode.cn/problems/next-greater-element-i/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-w/">Next Greater Element I</a></p></blockquote><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Monotonic Stack is a stack where elements are in monotonically order. It is mostly used for solving the “Next Greater Element” problems such as finding the next higher temperature in the “Daily Temperatures”. Sometimes the index of the elements are stored instead of the elements themselves for convenience. In the “Next Greater Element Problem”, for instance, we aim to identify the event of greater element occurring and to perform certain tasks when it happens. In “Daily Temperatures”, the task is to find the date of the next higher temperature while in the “Trapping Rain Water”, the task becomes computing the volume of water trapped in the convex. This article is to summarize the usage of monotonic stack in solving such problems.</p><h1 id="Next-Greater-Element-Leedcode-496"><a href="#Next-Greater-Element-Leedcode-496" class="headerlink" title="Next Greater Element - Leedcode 496"></a>Next Greater Element - Leedcode 496</h1><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.</p><p>You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.</p><p>For each 0 &lt;&#x3D; i &lt; nums1.length, find the index j such that nums1[i] &#x3D;&#x3D; nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.</p><p>Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.</p><p>Example 1:</p><p>Input: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2]<br>Output: [-1,3,-1]<br>Explanation: The next greater element for each value of nums1 is as follows:</p><ul><li>4 is underlined in nums2 &#x3D; [1,3,4,2]. There is no next greater element, so the answer is -1.</li><li>1 is underlined in nums2 &#x3D; [1,3,4,2]. The next greater element is 3.</li><li>2 is underlined in nums2 &#x3D; [1,3,4,2]. There is no next greater element, so the answer is -1.</li></ul><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>Other than brute force method, this is a typical problem for monotonic stack. What we want to do is assign the value of the next greater element to the current index. As $nums1$ is not strictly following the order of $nums2$, it is better to create a hashtable while iterating $nums2$ for later look-up. The steps to finding such greater numbers of $nums2$ are:</p><ul><li>create an empty stack and list for answer: $ans &#x3D; [-1]*len(nums2)$</li><li>iterate elements in $nums2$, compare it with the element at the top of stack if there is any. If if is smaller or equal(depending on the requirement of the problem) to the peek, push it into the stack. otherwise, keep popping the peek elements out until the new peek of the stack is bigger or the stack is empty. I store the index of the elements instead of the elements themselves in the stack for convenient assignment. Whenever a element: $nums[j]$ got popped out because of another element $nums2[i]$, assign the value of $nums[i]$ to the answer list: $ans[j] &#x3D; nums2[i]$.</li></ul><p>In such way, the stack maintains a way of decreasing elements and the code is as below:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        ans = [-<span class="number">1</span>]*<span class="built_in">len</span>(nums1)</span><br><span class="line">        look_up_table = [-<span class="number">1</span>]*<span class="built_in">len</span>(nums2)</span><br><span class="line">        <span class="comment"># obatin the look up table</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums2):</span><br><span class="line">            hashtable[num] = i</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> num &gt; nums2[stack[-<span class="number">1</span>]]:</span><br><span class="line">                prev_index = stack.pop()</span><br><span class="line">                look_up_table[prev_index] = nums2[i]</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="comment"># get the results</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums1)):</span><br><span class="line">            ans[index] = look_up_table[hashtable[nums1[index]]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Leedcode-503 is the same question but with a circular array, which is while looking for greater elements, the current element does not stop at the end of the array but continue traversing from the head until itself. Simply concatenating the array with itself and do the same thing on the new array will address the problem: $Nums &#x3D; nums+ nums$. LeedCode-739 “Daily Temperatures” is the similar problem only now we want to know how many days we need to wait for a higher daily temperature. This can be simply solved with subtraction of the index. The code can be found in Leedcode therefore will not be posted here.  </p><h1 id="Trapping-Rain-Water-Leedcode-42"><a href="#Trapping-Rain-Water-Leedcode-42" class="headerlink" title="Trapping Rain Water - Leedcode 42"></a>Trapping Rain Water - Leedcode 42</h1><h2 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h2><p>Given $n$ non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</p><p>Example:</p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="Trapping Water"></p><p>Input: height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>Output: 6<br>Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>The difficulty is to recognize that whenever height value at index of $i$ is greater than $i+1$, we want to know the convex column formed by $i-2$ and $i$. This is a typical “Next Greater Element”: perform a operation whenever a greater element occur than the element at the top of the stack.</p><p>A starting method to solve the problem is  find the highest left wall and right wall for every slots then compute the use the lower wall of them to subtract the slot to find the water unit specifically saved by this slow. If the lower of them is lower than the current unit, no water is saved by this slow:<br><img src="https://pic.leetcode-cn.com/542754f4431d93141920185252aee31664a96dd17285b92dfe390e9e977bebb1-image.png" alt="Scheme of Walls"></p><p>To find the walls, the first method is of course Brute Force, whereas the time complexity is $O(n^2)$ and space complexity is $O(1)$ as we only need to the current highest walls. To simplify, dynamic programming is used where the highest walls from previous iteration are compared with the left and right wall of the current slot and get the updated highest walls. In such way, there is no need to traverse the whole array again for every slots. This will decrease the time complexity to $O(n)$. The space complexity is now $o(n)$ as the highest walls of every slot need to be kept. The code of this method will not be presented in this article as it does not concern with monotonic stack.</p><p>The idea is the same as in the “Next Greater Element”. Whenever a higher height appears, it pops out the top element and compare the new top element with this higher value. This resembles the brackets in the calculator problem.<br>Scheme:<br><img src="https://pic.leetcode-cn.com/37fccd915f959c2046ffc1ab2b0a1e4d921869337d8d5d4aa218886ab0bf7c8a-image.png" alt="Brackets &amp; Rain">.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python code</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N):</span><br><span class="line">            h = height[i]</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> h&gt; height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                low_index = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    height_diff = <span class="built_in">min</span>(h, height[stack[-<span class="number">1</span>]])-height[low_index]</span><br><span class="line">                    <span class="built_in">sum</span> += height_diff* (i-stack[-<span class="number">1</span>]-<span class="number">1</span>) <span class="comment"># The index difference is the length</span></span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Validate Stack Sequences</title>
      <link href="/Blog/2022/07/11/Algorithms/ValidateStack/"/>
      <url>/Blog/2022/07/11/Algorithms/ValidateStack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考: <a href="https://leetcode.cn/problems/validate-stack-sequences/solution/yan-zheng-zhan-xu-lie-by-leetcode/">Validate Stack Sequences</a></p></blockquote><h1 id="Leedcode-946"><a href="#Leedcode-946" class="headerlink" title="Leedcode 946"></a>Leedcode 946</h1><p>Given two integer arrays $pushed$ and $popped$ each with distinct values, return $true$ if this could have been the result of a sequence of push and pop operations on an initially empty stack, or $false$ otherwise.</p><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We might do the following sequence:</span><br><span class="line">push(1), push(2), push(3), push(4),</span><br><span class="line">pop() -&gt; 4,</span><br><span class="line">push(5),</span><br><span class="line">pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: 1 cannot be popped before 2.</span><br></pre></td></tr></table></figure><p>Constraints:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 1 &lt;= pushed.length &lt;= 1000</span><br><span class="line">* 0 &lt;= pushed[i] &lt;= 1000</span><br><span class="line">* All the elements of pushed are unique.</span><br><span class="line">* popped.length == pushed.length</span><br><span class="line">* popped is a permutation of pushed</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>The problem uses Simulation method: create a empty stack and simulate the constructing process of $popped$ from $pushed$. Assuming successful construction, it is easy to notice that the number of pop operation should be the length of $popped$ no matter what the order is. The restrictions are, therefore, essential in the construction: the maximum number of \b{pop}; the numbers in $pushed$ can run out only once; Hence, at $i&#x3D;0,1,2…N-1$ iteration, the $i_{th}$ number of the $pushed$ is pushed into the new stack. Then do the stack popping on while loop with the conditions:</p><ul><li>The new stack is not empty</li><li>The number of pop operation: $j$ hasn’t reached the length of $popped$</li><li>The number at the top of the new stack (the one that is just popped) equals to the $j_{th}$ number of $popped$. It has to be exactly the $j_{th}$ because the order of popped elements won’t match otherwise.</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python code</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">validateStackSequences</span>(<span class="params">pushed: <span class="type">List</span>[<span class="built_in">int</span>], popped: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    new_stack = <span class="built_in">list</span>()</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    N = <span class="built_in">len</span>(pushed)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> pushed:</span><br><span class="line">        new_stack.append(num)</span><br><span class="line">        <span class="keyword">while</span> new_stack <span class="keyword">and</span> j&lt; N <span class="keyword">and</span> new_stack[-<span class="number">1</span>] == popped[j]:</span><br><span class="line">            new_stack.pop()</span><br><span class="line">            j+=<span class="number">1</span>      </span><br><span class="line">    <span class="keyword">return</span> j == N</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>This question tests the usage of stack structure and familiarize me with Simulation method.  </p>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Calculator</title>
      <link href="/Blog/2022/07/10/Algorithms/Calculator/"/>
      <url>/Blog/2022/07/10/Algorithms/Calculator/</url>
      
        <content type="html"><![CDATA[<blockquote><small><i>设计一个计算器最头疼的就是中序后缀表达式中的括号，比如3+4x5 与 (3+4)x5 的计算顺序造成结果不一样。一个经典的解决办法就是将其转化成后缀表达式，也称逆波兰式。本文章是因为经常碰到设计计算器或者类似的题目，做一个总结来捋一捋。</i></small></blockquote><h2 id="Reverse-Polish-notation"><a href="#Reverse-Polish-notation" class="headerlink" title="Reverse Polish notation"></a>Reverse Polish notation</h2><p>The idea of Reverse Polish notation is to convert the infix notation into a format of:<br>$$ (Num_{left})\ (Num_{right})\ Ops $$<br>and maintain that for the whole expression. Where there are consecutive operands, the operand with higher priority goes first. For instance:<br>$$ 3-4\times 5 &#x3D;&gt; 3\quad4\quad5\times- $$<br>and conversely:<br>$$ (3-4)\times 5 &#x3D;&gt; 3\quad4 - 5\times\quad$$<br>Later in the calculating, whenever the program read a operand from the postfix expression, it pops out the previous two numbers, calculate with the operand and push the result back to the stack. Eventually, the last number left in the stack will be the result of the equation.</p><h2 id="Infix-to-Postfix"><a href="#Infix-to-Postfix" class="headerlink" title="Infix to Postfix"></a>Infix to Postfix</h2><p>So we know how Reverse Polish notation can be useful. What’s next is how to generate it from infix expression. Let’s start from the easy part where there aren’t any brackets. In such case, the converter only cares about the priority:</p><ul><li>‘*’ and ‘&#x2F;‘ have higher priority than ‘+’ and ‘-‘</li><li>When the priorities are equal, operand on the left has higher priority</li></ul><p>Hence, create stacks $\color{red}{ops}$ to store the operands and $\color{green}{out}$, read chars from the infix expression:</p><ul><li>If a char is a number, push it into $\color{green}{out}$</li><li>If a char is a operand, compare it with the operand at the top of the $\color{red}{ops}$:<ul><li>If it has higher priority, push it into $\color{red}{ops}$</li><li>If it has lower or equal priority, pop a operand from $\color{red}{ops}$ and push it into $\color{green}{out}$ until finding the next ‘higher’ operand. Then push the new char into<br>$$\color{red}{ops}$.</li></ul></li><li>When the iteration on Infix expression finish, pop what’s left in $\color{red}{ops}$ and push into $\color{green}{out}$.</li></ul><p>Now brings in the brackets, what it does is simply making a mark for ‘coming back’ that functions as the ‘higher’ operand. That is, when the char is ‘)’, the $\color{red}{ops}$ keeps popping elements and pushing them into $\color{green}{out}$ until it pops out the nearest ‘(‘. To avoid ‘(‘ from disrupting other operands’ popping, the priority of ‘(‘ is set to be the lowest. Note: No need to set ‘)’ priority because it will never be pushed into the stack.</p><p>Example:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python code</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">infixToPost</span>(<span class="params">s</span>):</span><br><span class="line">    level = &#123;&#125;</span><br><span class="line">    level[<span class="string">&#x27;*&#x27;</span>] = <span class="number">3</span></span><br><span class="line">    level[<span class="string">&#x27;/&#x27;</span>] = <span class="number">3</span></span><br><span class="line">    level[<span class="string">&#x27;+&#x27;</span>] = <span class="number">2</span></span><br><span class="line">    level[<span class="string">&#x27;-&#x27;</span>] = <span class="number">2</span></span><br><span class="line">    level[<span class="string">&#x27;(&#x27;</span>] = <span class="number">1</span></span><br><span class="line">    nums = <span class="string">&#x27;0123456789&#x27;</span></span><br><span class="line">    ops = <span class="string">&#x27;()+-*/&#x27;</span></span><br><span class="line">    out = <span class="built_in">list</span>()</span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> nums:</span><br><span class="line">            out.append(c)</span><br><span class="line">        <span class="keyword">elif</span> c <span class="keyword">in</span> ops:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">while</span> (sign := stack.pop()) != <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    out.append(sign)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> level[stack[-<span class="number">1</span>]] &gt;= level[c]:</span><br><span class="line">                    out.append(stack.pop())</span><br><span class="line">                stack.append(c)</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        out.append(stack.pop())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(out)</span><br></pre></td></tr></table></figure><h2 id="Calculation"><a href="#Calculation" class="headerlink" title="Calculation"></a>Calculation</h2><p>The idea has been explained in the previous section:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># calculation</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">postfix_eval</span>(<span class="params">postfix_expr</span>):</span><br><span class="line">    operand_stack =Stack()</span><br><span class="line">    postfix_list = postfix_expr.split()</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> postfix_list:</span><br><span class="line">        <span class="keyword">if</span> token.isnumeric():</span><br><span class="line">            operand_stack.push(<span class="built_in">int</span>(token))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            top_operand2 = operand_stack.pop()</span><br><span class="line">            top_operand1 = operand_stack.pop()</span><br><span class="line">            result = do_math(token,top_operand1,top_operand2)</span><br><span class="line">            operand_stack.push(result)</span><br><span class="line">    <span class="keyword">return</span> operand_stack.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace the string to operator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_math</span>(<span class="params">op, op1, op2</span>):</span><br><span class="line">    <span class="keyword">if</span> op == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1+op2</span><br><span class="line">    <span class="keyword">elif</span> op==<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1-op2</span><br><span class="line">    <span class="keyword">elif</span> op==<span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1*op2</span><br><span class="line">    <span class="keyword">elif</span> op==<span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1/op2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Practice-Leedcode-224"><a href="#Practice-Leedcode-224" class="headerlink" title="Practice: Leedcode 224"></a>Practice: Leedcode 224</h2><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. Example 1: s &#x3D; “1 + 1”, output: 2; Example 2: s &#x3D; “2 -1 + 2”, output: 3; Example 3: s &#x3D; “(1+(4+5+2)-3)+(6+8)” , output: 23.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>As there are only addition and subtraction, no need to consider the priority but only the brackets. The idea is to keep track of the result from the left equation, the sign (+&#x2F;-) and the number as the right equation (similar to postfix). When the program read ‘(‘, it stack the res and sign, then reset them as 0s to tackle the equation inside the bracket as a new equation:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">s</span>):</span><br><span class="line">    res, num, sign = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c.isdigit():</span><br><span class="line">            num = <span class="number">10</span> * num +<span class="built_in">int</span>(c)</span><br><span class="line">        <span class="keyword">elif</span> c ==<span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c ==<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            res = res + sign*num</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            sign = <span class="number">1</span> <span class="keyword">if</span> c ==<span class="string">&#x27;+&#x27;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            stack.append(res)</span><br><span class="line">            stack.append(sign)</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            res += sign*num</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            res *= stack.pop()</span><br><span class="line">            res += stack.pop()</span><br><span class="line">    res += sign * num</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>简而言之，计算器的关键是要用栈来构建后缀表达式。在后缀表达式中，先使用的计算符会放在前面，保证计算过程中会被先执行。而构建后缀的方法则是创建一个操作符栈，每当新的符号优先级低于操作符栈顶端的符号，则会弹出栈里面的优先级别大于或等于新符号的所有操作符，并放进输出。与此同时，类似的如果新的操作符是右括号，则会弹出并压入输出栈所有在左括号上方的所有符号，依次压入输出栈。迭代完后，把操作符栈剩下的符号以此弹出压入输出。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>Wikipedia. Reverse Polish notation. <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation#Explanation">https://en.wikipedia.org/wiki/Reverse_Polish_notation#Explanation</a></li><li>Leedcode. Basic calculator. <a href="https://leetcode.cn/problems/basic-calculator/">https://leetcode.cn/problems/basic-calculator/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xv6 Lab Utilities</title>
      <link href="/Blog/2022/07/08/Xv6/Xv6-Lab-Utilities/"/>
      <url>/Blog/2022/07/08/Xv6/Xv6-Lab-Utilities/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考: <a href="https://clownote.github.io/2021/02/24/xv6/Xv6-Lab-Utilities/">Lab: Xv6 and Unix utilities</a></p></blockquote><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>Implement the UNIX program <code>sleep</code> for xv6; your <code>sleep</code> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p><p>Some hints:</p><ul><li>Before you start coding, read Chapter 1 of the <a href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">xv6 book</a>.</li><li>Look at some of the other programs in <code>user/</code> (e.g., <code>user/echo.c</code>, <code>user/grep.c</code>, and <code>user/rm.c</code>) to see how you can obtain the command-line arguments passed to a program.</li><li>If the user forgets to pass an argument, sleep should print an error message.</li><li>The command-line argument is passed as a string; you can convert it to an integer using <code>atoi</code> (see user&#x2F;ulib.c).</li><li>Use the system call <code>sleep</code>.</li><li>See <code>kernel/sysproc.c</code> for the xv6 kernel code that implements the <code>sleep</code> system call (look for <code>sys_sleep</code>), <code>user/user.h</code> for the C definition of <code>sleep</code> callable from a user program, and <code>user/usys.S</code> for the assembler code that jumps from user code into the kernel for <code>sleep</code>.</li><li>Make sure <code>main</code> calls <code>exit()</code> in order to exit your program.</li><li>Add your <code>sleep</code> program to <code>UPROGS</code> in Makefile; once you’ve done that, <code>make qemu</code> will compile your program and you’ll be able to run it from the xv6 shell.</li><li>Look at Kernighan and Ritchie’s book <em>The C programming language (second edition)</em> (K&amp;R) to learn about C.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ticks;  <span class="comment">// time to sleep</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: sleep ticks\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ticks = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  sleep(ticks);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>build &amp; run:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ <span class="built_in">sleep</span> 10</span><br><span class="line">(nothing happens <span class="keyword">for</span> a little <span class="keyword">while</span>)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<code>&lt;pid&gt;: received ping</code>“, where <code>&lt;pid&gt;</code> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<code>&lt;pid&gt;: received pong</code>“, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</p><p>Some hints:</p><ul><li>Use <code>pipe</code> to create a pipe.</li><li>Use <code>fork</code> to create a child.</li><li>Use <code>read</code> to read from the pipe, and <code>write</code> to write to the pipe.</li><li>Use <code>getpid</code> to find the process ID of the calling process.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li><li>User programs on xv6 have a limited set of library functions available to them. You can see the list in <code>user/user.h</code>; the source (other than for system calls) is in <code>user/ulib.c</code>, <code>user/printf.c</code>, and <code>user/umalloc.c</code>.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p[<span class="number">2</span>];  <span class="comment">// file descriptors for pipe</span></span><br><span class="line"><span class="type">char</span> recv_buf[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">pipe(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// child</span></span><br><span class="line">read(p[<span class="number">0</span>], recv_buf, <span class="number">4</span>);</span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>, getpid(), recv_buf);</span><br><span class="line"></span><br><span class="line">write(p[<span class="number">1</span>], <span class="string">&quot;pong&quot;</span>, <span class="number">4</span>);</span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// parent</span></span><br><span class="line">write(p[<span class="number">1</span>], <span class="string">&quot;ping&quot;</span>, <span class="number">4</span>);</span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">read(p[<span class="number">0</span>], recv_buf, <span class="number">4</span>);</span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>, getpid(), recv_buf);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ pingpong</span><br><span class="line">4: received ping</span><br><span class="line">3: received pong</span><br></pre></td></tr></table></figure><h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p><p>Your goal is to use <code>pipe</code> and <code>fork</code> to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35.</p><p>Some hints:</p><ul><li>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</li><li>Once the first process reaches 35, it should wait until the entire pipeline terminates, including all children, grandchildren, &amp;c. Thus the main primes process should only exit after all the output has been printed, and after all the other primes processes have exited.</li><li>Hint: <code>read</code> returns zero when the write-side of a pipe is closed.</li><li>It’s simplest to directly write 32-bit (4-byte) <code>int</code>s to the pipes, rather than using formatted ASCII I&#x2F;O.</li><li>You should create the processes in the pipeline only as they are needed.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li></ul><p>例程1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_PRIME 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">generate_natural</span><span class="params">()</span>;  <span class="comment">// -&gt; out_fd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">prime_filter</span><span class="params">(<span class="type">int</span> in_fd, <span class="type">int</span> prime)</span>;  <span class="comment">// -&gt; out_fd</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> prime;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> in = generate_natural();</span><br><span class="line"><span class="keyword">while</span> (read(in, &amp;prime, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line"><span class="comment">// printf(&quot;prime %d: in_fd: %d\n&quot;, prime, in);  // debug</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">in = prime_filter(in, prime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成自然数: 2, 3, 4, ..&lt; MAX</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">generate_natural</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> out_pipe[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">pipe(out_pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = FIRST_PRIME; i &lt; MAX; i++) &#123;</span><br><span class="line">write(out_pipe[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line">close(out_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(out_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out_pipe[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 素数筛</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">prime_filter</span><span class="params">(<span class="type">int</span> in_fd, <span class="type">int</span> prime)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span> out_pipe[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">pipe(out_pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line"><span class="keyword">while</span> (read(in_fd, &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (num % prime) &#123;</span><br><span class="line">write(out_pipe[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(in_fd);</span><br><span class="line">close(out_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(in_fd);</span><br><span class="line">close(out_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out_pipe[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序是参考 《<a href="https://chai2010.cn/advanced-go-programming-book/">Go语言高级编程</a>》<a href="https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-06-goroutine.html">1.6 常见的并发模式</a> 中的那个 Golang 版本写的。Golang 的并发模型和 UNIX Pipe 本身就很像（refer: <a href="https://golang.google.cn/doc/effective_go#sharing">Effective Go: Share by communicating</a>），这里只需把 chan 换成 pipe，Goroutine 换成 fork 的进程。但是，一定要、一定要、一定要注意那些在子进程中使用的文件描述符，父进程不用就要关了，不然就凉了。</p><p>例程2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">source</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="keyword">for</span> (num=<span class="number">2</span>;num&lt;<span class="number">35</span>;num++)&#123;</span><br><span class="line">write(<span class="number">1</span>,&amp;num, <span class="keyword">sizeof</span>(num));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">filter</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line"><span class="type">int</span> n ;</span><br><span class="line"><span class="keyword">while</span>(read(<span class="number">0</span>,&amp;n,<span class="keyword">sizeof</span>(n)))&#123;</span><br><span class="line"><span class="keyword">if</span> (n%p !=<span class="number">0</span>)&#123;write(<span class="number">1</span>,&amp;n,<span class="keyword">sizeof</span>(n));&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">redirect</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> pd[])</span>&#123;</span><br><span class="line">close(k);</span><br><span class="line">dup(pd[k]);</span><br><span class="line">close(pd[<span class="number">0</span>]);</span><br><span class="line">close(pd[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sink</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> pd[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line"><span class="keyword">if</span>(read(<span class="number">0</span>,&amp;p,<span class="keyword">sizeof</span>(p)))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;prime: %d\n&quot;</span>, p);</span><br><span class="line">pipe(pd);</span><br><span class="line"><span class="keyword">if</span>(fork())&#123;</span><br><span class="line">redirect(<span class="number">0</span>,pd);</span><br><span class="line">sink();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">redirect(<span class="number">1</span>,pd);</span><br><span class="line">filter(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> pd[<span class="number">2</span>];</span><br><span class="line">pipe(pd);</span><br><span class="line"><span class="keyword">if</span>(fork()&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// parent process redirects the standard input to pd[0]</span></span><br><span class="line">redirect(<span class="number">0</span>,pd);</span><br><span class="line">sink();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//child process redirect the standard ouput to pd[1]</span></span><br><span class="line">redirect(<span class="number">1</span>, pd);</span><br><span class="line">source();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>运行·结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ primes</span><br><span class="line">prime 2</span><br><span class="line">prime 3</span><br><span class="line">prime 5</span><br><span class="line">prime 7</span><br><span class="line">prime 11</span><br><span class="line">prime 13</span><br><span class="line">prime 17</span><br><span class="line">prime 19</span><br><span class="line">prime 23</span><br><span class="line">prime 29</span><br><span class="line">prime 31</span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file <code>user/find.c</code>.</p><p>Some hints:</p><ul><li>Look at user&#x2F;ls.c to see how to read directories.</li><li>Use recursion to allow find to descend into sub-directories.</li><li>Don’t recurse into “.” and “..”.</li><li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li><li>You’ll need to use C strings. Have a look at K&amp;R (the C book), for example Section 5.5.</li><li>Note that &#x3D;&#x3D; does not compare strings like in Python. Use strcmp() instead.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find first character after last slash.</span></span><br><span class="line"><span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">;</span><br><span class="line">p++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *targetname)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(fmtname(path), targetname)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open [%s], fd=%d\n&quot;</span>, path, fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (st.type != T_DIR) &#123;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// st.type == T_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">*p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line"><span class="keyword">if</span> (de.inum == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">memmove(p, de.name, DIRSIZ);</span><br><span class="line">p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">find(buf, targetname);</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: find path filename\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是抄 <code>user/ls.c</code>。这个指针玩的，，太骚了[捂脸]: $path$被复制到$buf$，然后创建一个指针$*p$指向$buf$的首字符地址，后面加一个“&#x2F;”，接着把$p$递增指向下一位。这样做有什么好处呢，之后只需要不停从fd读取文件名，此处$de$是$dirent$，是文件标志符的基本单元，定义在$“kernel&#x2F;fs.h”$中。然后不断把$de.name$通过$memmove$这个函数赋值给指针$p$。然后从$buf$的首地址读取会得到当前文件的全地址。同时该函数用到了递归，知道吧目标路径和其所有子路径的文件都对比一遍，发现目标文件名则输出全地址，否则查完收工。</p><p>结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &gt; b</span><br><span class="line">$ <span class="built_in">mkdir</span> a</span><br><span class="line">$ <span class="built_in">echo</span> &gt; a/b</span><br><span class="line">$ find . b</span><br><span class="line">./b</span><br><span class="line">./a/b</span><br></pre></td></tr></table></figure><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p><p>The following example illustrates xarg’s behavior:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello too | xargs <span class="built_in">echo</span> <span class="built_in">bye</span></span><br><span class="line"><span class="built_in">bye</span> hello too</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>Note that the command here is “echo bye” and the additional arguments are “hello too”, making the command “echo bye hello too”, which outputs “bye hello too”.</p><p>Please note that xargs on UNIX makes an optimization where it will feed more than argument to the command at a time. We don’t expect you to make this optimization. To make xargs on UNIX behave the way we want it to for this lab, please run it with the -n option set to 1. For instance</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;1\n2&quot;</span> | xargs -n 1 <span class="built_in">echo</span> line</span><br><span class="line">line 1</span><br><span class="line">line 2</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>Some hints:</p><ul><li>Use <code>fork</code> and <code>exec</code> to invoke the command on each line of input. Use <code>wait</code> in the parent to wait for the child to complete the command.</li><li>To read individual lines of input, read a character at a time until a newline (‘\n’) appears.</li><li>kernel&#x2F;param.h declares MAXARG, which may be useful if you need to declare an argv array.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li><li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li></ul><p>xargs, find, and grep combine well:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . b | xargs grep hello</span><br></pre></td></tr></table></figure><p>will run “grep hello” on each file named b in the directories below “.”.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span>  <span class="comment">// MAXARG</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> is_blank(chr) (chr == <span class="string">&#x27; &#x27;</span> || chr == <span class="string">&#x27;\t&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">2048</span>], ch;</span><br><span class="line"><span class="type">char</span> *p = buf;</span><br><span class="line"><span class="type">char</span> *v[MAXARG]; <span class="comment">// declares p as an array of MAXARG pointers</span></span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="type">int</span> blanks = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: xargs &lt;command&gt; [argv...]\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">1</span>; c &lt; argc; c++) &#123;</span><br><span class="line">v[c<span class="number">-1</span>] = argv[c];</span><br><span class="line">&#125;</span><br><span class="line">--c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (read(<span class="number">0</span>, &amp;ch, <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_blank(ch)) &#123;</span><br><span class="line">blanks++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (blanks) &#123;  <span class="comment">// 之前有过空格</span></span><br><span class="line">buf[offset++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">v[c++] = p;</span><br><span class="line">p = buf + offset;</span><br><span class="line"></span><br><span class="line">blanks = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ch != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">buf[offset++] = ch;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">v[c++] = p;</span><br><span class="line">p = buf + offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line"><span class="built_in">exit</span>(exec(v[<span class="number">0</span>], v));</span><br><span class="line">&#125;</span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">c = argc - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是字符串操作麻烦。。知识点回顾：</p><ul><li>数组名只有在$sizeof(数组名)$ 和$&amp;数组名$ 两种情况表示整个数组的地址， 其他情况表示数组首元素的地址。</li><li>故而: $&amp;a$和$&amp;a[0]$虽然值是一样，但是返回的类型不一样，前者是指向数组的地址，后者是指向数组首元素的地址，前者的指针+1 指向下一个数组，后者+1指向该数组的第二个元素。但是$a$与$&amp;a[0]$是一样的。</li><li>$int *p[3]$ 声明一个数组p，包含三个指针元素， 指针元素各都指向一个integer; $int(*p)[3]$声明一个数组指针p，数组包含三个integer。</li></ul><p>运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello too | xargs <span class="built_in">echo</span> <span class="built_in">bye</span></span><br><span class="line"><span class="built_in">bye</span> hello too</span><br><span class="line">$ find . b</span><br><span class="line">./b</span><br><span class="line">./a/b</span><br><span class="line">$ find . b | xargs <span class="built_in">echo</span> hello</span><br><span class="line">hello ./b</span><br><span class="line">hello ./a/b</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>MIT. Lab guidance. <a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html</a></li><li>MIT. Lab: Xv6 and Unix utilities. <a href="https://pdos.csail.mit.edu/6.S081/2020/labs/util.html">https://pdos.csail.mit.edu/6.S081/2020/labs/util.html</a></li><li>KatyuMarisa. MIT 6.S081 xv6调试不完全指北. <a href="https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html">https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html</a></li><li>lhw–9999. xv6操作系统实验 – 质数筛. <a href="https://blog.csdn.net/lhwhit/article/details/108342724">https://blog.csdn.net/lhwhit/article/details/108342724</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xv6 编写用户程序</title>
      <link href="/Blog/2022/06/21/Xv6/Xv6-add-user-program/"/>
      <url>/Blog/2022/06/21/Xv6/Xv6-add-user-program/</url>
      
        <content type="html"><![CDATA[<h1 id="Xv6-编写用户程序"><a href="#Xv6-编写用户程序" class="headerlink" title="Xv6 编写用户程序"></a>Xv6 编写用户程序</h1><p>如何在 Xv6（<a href="https://github.com/mit-pdos/xv6-riscv">xv6-riscv</a>）中添加自己编写的用户程序，比如实现一个 <code>helloworld</code>？</p><h2 id="1-编写代码"><a href="#1-编写代码" class="headerlink" title="1. 编写代码"></a>1. 编写代码</h2><p>在 <code>xv6-riscv/user/</code> 里新建一个 <code>helloworld.c</code>，写一个 hello world：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个和平时我们在真实系统中写的代码有少许区别：</p><ol><li>导库：<code>kernel/types.h</code>, <code>kernel/stat.h</code>, <code>user/user.h</code>。你可以看到  <code>xv6-riscv/user/*.c</code> 头三行基本都是这么写的，咱们有样学样就可。（这三行大概就是 include <code>&lt;stdio.h&gt;</code>，<code>&lt;stdlib.h&gt;</code>，<code>&lt;unistd.h&gt;</code> ）</li><li>不要 <code>return 0;</code>，要 <code>exit(0);</code>（否则你会得到一个运行时的 <code> unexpected scause 0x000000000000000f</code>）。这一点同样可以参考其他系统随附的程序得出。</li></ol><h2 id="2-修改-Makefile"><a href="#2-修改-Makefile" class="headerlink" title="2. 修改 Makefile"></a>2. 修改 Makefile</h2><p><code>Xv6</code> 系统中没有编译器的实现，所以我们需要把程序在编译系统时一并编译。修改 <code>xv6-riscv/Makefile</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim Makefile</span><br></pre></td></tr></table></figure><p>找到 <code>UPROGS</code> (大概118行)，保持格式，在后面添加注册新程序：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">$U/_cat\</span><br><span class="line">$U/_echo\</span><br><span class="line">...</span><br><span class="line">$U/_helloworld\</span><br></pre></td></tr></table></figure><p>编写的代码 <code>user/xxx.c</code>，对应这里写 <code>$U/_xxx\</code>。</p><h2 id="3-编译运行-Xv6"><a href="#3-编译运行-Xv6" class="headerlink" title="3. 编译运行 Xv6"></a>3. 编译运行 Xv6</h2><p>编译运行 Xv6：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br></pre></td></tr></table></figure><p>在 Xv6 中 <code>ls</code>，可以看到我们的 helloworld 程序：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">...</span><br><span class="line">helloworld   2 20 22352</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ helloworld</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>That’s it!</p><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># By CDFMLR 2021-02-17</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;See you.&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xv6 多进程编程</title>
      <link href="/Blog/2022/06/21/Xv6/Xv6-Processes/"/>
      <url>/Blog/2022/06/21/Xv6/Xv6-Processes/</url>
      
        <content type="html"><![CDATA[<h1 id="Xv6-多进程编程"><a href="#Xv6-多进程编程" class="headerlink" title="Xv6 多进程编程"></a>Xv6 多进程编程</h1><blockquote><p>参考: <a href="https://github.com/mit-pdos/xv6-riscv-book">xv6-riscv-book</a> 1.1 Processes and memory</p></blockquote><p>本文参考 xv6-riscv-book，介绍如何使用 Xv6 系统调用，实现多进程编程。（其实就是把书上的代码完整化，并附上真实系统中的实现方式）</p><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td><code>int fork()</code></td><td>创建一个进程（通过复制当前进程）返回子进程 PID</td></tr><tr><td><code>int exit(int status)</code></td><td>终止当前进程，status 会被报告给 wait()，无返回值</td></tr><tr><td><code>int wait(int *status)</code></td><td>等待一个子进程退出，把退出的状态(exit de status) 写到 status，返回退出的子进程 PID</td></tr><tr><td><code>int exec(char *file, char *argv[])</code></td><td>载入一个文件，并以指定参数执行之。错误才返回</td></tr></tbody></table><h2 id="fork-amp-wait"><a href="#fork-amp-wait" class="headerlink" title="fork &amp; wait"></a>fork &amp; wait</h2><p>fork 系统调用通过复制当前进程，创建一个进程，返回子进程 PID。</p><p>wait 会等待当前进程的某个子进程退出（调用 exit）。</p><h3 id="Xv6"><a href="#Xv6" class="headerlink" title="Xv6"></a>Xv6</h3><p>书上有关使用 <code>fork</code> 的代码的完整实现（在 Xv6 下运行。Help: <a href="https://blog.csdn.net/u012419550/article/details/113836258">Xv6 编写用户程序</a>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usefork.c for xv6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">pid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在 Xv6 里提供的 printf 线程不安全，运行程序打印出的字符可能随机混合在一起：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ usefork   <span class="comment"># 这个还稍好</span></span><br><span class="line">parent: child=c5</span><br><span class="line">hild: exiting</span><br><span class="line">child 5 is <span class="keyword">done</span></span><br><span class="line">$ usefork  <span class="comment"># 这个就非常乱了</span></span><br><span class="line">cphairledn:t :e xcihtiilndg=</span><br><span class="line">7</span><br><span class="line">child 7 is <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="Real-Unix"><a href="#Real-Unix" class="headerlink" title="Real Unix"></a>Real Unix</h3><p>在真实的 <code>*nix</code> 系统上（这里以 macOS 11，GCC 10 为例），这段代码的写法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usefork.c for macOS GCC</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">pid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line"><span class="comment">// sleep(2);</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实系统中运行的效果会好一些，一般没有字符混合的情况：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc-10 usefork.c ; ./a.out</span><br><span class="line">parent: child=3598</span><br><span class="line">child: exiting</span><br><span class="line">child 3598 is <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>exec 系统调用载入一个可执行文件，用其替换自身程序，以指定参数执行之。</p><h3 id="Xv6-1"><a href="#Xv6-1" class="headerlink" title="Xv6"></a>Xv6</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useexec.c for Xv6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">exec(<span class="string">&quot;echo&quot;</span>, argv);</span><br><span class="line"><span class="comment">// exec 成功了会替换程序，下面的就执行不到了:</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ useexec</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h3 id="Real-Unix-1"><a href="#Real-Unix-1" class="headerlink" title="Real Unix"></a>Real Unix</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useexec.c for macOS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">execv(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br><span class="line"><span class="comment">// execv(&quot;/bin/echooooo&quot;, argv);  // an error one</span></span><br><span class="line"><span class="comment">// exec 成功了会替换程序，下面的就执行不到了:</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc-10 useexec.c ; ./a.out</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><hr><p>正文结束。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># By CDFMLR 2021-02-18</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;See you.🥷&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xv6 管道</title>
      <link href="/Blog/2022/06/20/Xv6/Xv6-pipes/"/>
      <url>/Blog/2022/06/20/Xv6/Xv6-pipes/</url>
      
        <content type="html"><![CDATA[<h1 id="Xv6-管道"><a href="#Xv6-管道" class="headerlink" title="Xv6 管道"></a>Xv6 管道</h1><blockquote><p>参考: <a href="https://github.com/mit-pdos/xv6-riscv-book">xv6-riscv-book</a> 1.3 Pipes</p></blockquote><p>[TOC]</p><h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><p>Xv6 系统调用 <code>pipe()</code> 来创建管道。管道类似于 Go 语言中的 chan。在 Shell 里我们用 <code>|</code> 表示管道，对于命令： <code>echo &quot;hello world&quot; | wc</code>，可以用如下代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// upipe.c</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Runs the program wc with standard input connected to the read end of a pipe.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> p[<span class="number">2</span>];  <span class="comment">// file descriptors for the pipe</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// NULL</span></span><br><span class="line"></span><br><span class="line">pipe(p);  <span class="comment">// creates a new pipe: records the read and write file descriptors in the array p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// redirection</span></span><br><span class="line">close(<span class="number">0</span>);</span><br><span class="line">dup(p[<span class="number">0</span>]);  <span class="comment">// stdin = &lt;- pipe</span></span><br><span class="line"></span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">exec(<span class="string">&quot;wc&quot;</span>, argv);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);  <span class="comment">// pipe &lt;- str</span></span><br><span class="line"></span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ upipe</span><br><span class="line">1 2 12</span><br></pre></td></tr></table></figure><p>Xv6 sh 里的管道处理实现其实就和这段代码类似：fork 两个进程，分别重定向标准输出 or 输入、运行管道左右两边的命令。详见 <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/sh.c#L100">user&#x2F;sh.c:100</a>。</p><h2 id="管道-V-S-临时文件"><a href="#管道-V-S-临时文件" class="headerlink" title="管道 V.S. 临时文件"></a>管道 V.S. 临时文件</h2><p>用管道与用临时文件，使用上似乎区别不大：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 管道</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> | <span class="built_in">wc</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 临时文件</span></span><br><span class="line"><span class="built_in">echo</span> hello world &gt;/tmp/xyz; <span class="built_in">wc</span> &lt;/tmp/xyz</span><br></pre></td></tr></table></figure><p>但管道更好：</p><ul><li>管道会自动清理（临时文件要手动删除）</li><li>管道可以放任意长度的数据流（临时文件需要有足够的磁盘空间）</li><li>管道可以并行运行（临时文件只能一个运行完，第二个再开始）</li><li>在处理进程间通信问题时，管道的阻塞式读写比用非阻塞的临时文件方便。</li></ul><hr><p>EOF</p><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># By CDFMLR 2021-02-20</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;See you. 🪐&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xv6 I/O 与文件描述符</title>
      <link href="/Blog/2022/06/18/Xv6/Xv6-io-and-file-descriptors/"/>
      <url>/Blog/2022/06/18/Xv6/Xv6-io-and-file-descriptors/</url>
      
        <content type="html"><![CDATA[<h1 id="Xv6-I-x2F-O-与文件描述符"><a href="#Xv6-I-x2F-O-与文件描述符" class="headerlink" title="Xv6 I&#x2F;O 与文件描述符"></a>Xv6 I&#x2F;O 与文件描述符</h1><blockquote><p>参考: <a href="https://github.com/mit-pdos/xv6-riscv-book">xv6-riscv-book</a> 1.2 I&#x2F;O and File descriptors</p></blockquote><h2 id="Xv6-I-x2F-O-系统调用"><a href="#Xv6-I-x2F-O-系统调用" class="headerlink" title="Xv6 I&#x2F;O 系统调用"></a>Xv6 I&#x2F;O 系统调用</h2><p>本文会使用到如下 Xv6 的 I&#x2F;O 系统调用：</p><table><thead><tr><th>系统调用</th><th>说明</th></tr></thead><tbody><tr><td>int open(char *file, int flags)</td><td>打开一个文件，flags 用来指示读or写，返回一个文件描述符</td></tr><tr><td>int write(int fd, char *buf, int n)</td><td>从 buf 写 n 个字节到文件描述符 fd，返回写入的字节数</td></tr><tr><td>int read(int fd, char *buf, int n)</td><td>从文件描述符 fd 读 n 个字节到 buf，返回读取的字节数或 <code>0</code> 表示 EOF（文件结束）</td></tr><tr><td>int close(int fd)</td><td>释放打开的文件描述符 fd</td></tr><tr><td>int dup(int fd)</td><td>返回一个新的文件描述符，指向与 fd 相同的文件</td></tr></tbody></table><p>open 的 flags 由 <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/fcntl.h#L1-L5"> kernel&#x2F;fcntl.h:1-5</a> 提供：</p><table><thead><tr><th>flag</th><th>说明</th></tr></thead><tbody><tr><td>O_RDONLY</td><td>只读</td></tr><tr><td>O_WRONLY</td><td>只写</td></tr><tr><td>O_RDWR</td><td>读和写</td></tr><tr><td>O_CREATE</td><td>不存在时新建</td></tr><tr><td>O_TRUNC</td><td>把文件截断到 0 长度</td></tr></tbody></table><p>这些都是用 bit 描述的，可以做或运算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/dir/file&quot;</span>, O_CREATE|O_WRONLY);</span><br></pre></td></tr></table></figure><h2 id="Xv6-文件描述符"><a href="#Xv6-文件描述符" class="headerlink" title="Xv6 文件描述符"></a>Xv6 文件描述符</h2><p>文件描述符就是一个整数，用来代表一个打开的 IO 对象（如文件），通过文件描述符就可以对 IO 对象进行读写操作。程序一开始就会被分配给如下惯例文件描述符：</p><table><thead><tr><th>文件描述符</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>stdin  标准输入</td></tr><tr><td>1</td><td>stdout 标准输出</td></tr><tr><td>2</td><td>stderr 标准错误</td></tr></tbody></table><h2 id="read-amp-write"><a href="#read-amp-write" class="headerlink" title="read &amp; write"></a>read &amp; write</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useio.c</span></span><br><span class="line"><span class="comment">// Copies data from its standard input to its standard output.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span> buf);  <span class="comment">// 0: stdin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;  <span class="comment">// EOF</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read error\n&quot;</span>);  <span class="comment">// 2: stderr</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (write(<span class="number">1</span>, buf, n) != n) &#123;  <span class="comment">// 1: stdout</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序从标准输入读，写到标准输出，相当于一个简化的 cat：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ useio &gt; fff</span><br><span class="line">123456  <span class="comment"># 这是输入的</span></span><br><span class="line">$ useio &lt; fff</span><br><span class="line">123456  <span class="comment"># 这是输出的</span></span><br></pre></td></tr></table></figure><h2 id="重定向的实现"><a href="#重定向的实现" class="headerlink" title="重定向的实现"></a>重定向的实现</h2><p>在通过如 open 的系统调用打开一个文件时，被分配给的文件描述符总是当前可用的描述符中<strong>最小的</strong>。</p><p>用这个特性就可以实现输入输出的重定向。Xv6 的 Shell (<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/sh.c#L82">user&#x2F;sh.c:82</a>) 里就是这么实现的。</p><p>下面的程序实现一个 <code>cat &lt; input.txt</code> 的效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uredirection.c</span></span><br><span class="line"><span class="comment">// A simplified version of the code a shell runs for the command `cat &lt; input.txt`</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span>  <span class="comment">// define O_RDONLY</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// subprocess</span></span><br><span class="line">close(<span class="number">0</span>);  <span class="comment">// close stdin</span></span><br><span class="line"><span class="comment">// A newly allocated file descriptor is always the lowest-numbered unused descriptor of the current process.</span></span><br><span class="line">open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY);  <span class="comment">// 0 =&gt; input.txt</span></span><br><span class="line"><span class="comment">// exec replaces the calling process’s memory but preserves its file table.</span></span><br><span class="line">exec(<span class="string">&quot;cat&quot;</span>, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; input.txt</span><br><span class="line">&lt;Input something here&gt;</span><br><span class="line">$ uredirection</span><br><span class="line">&lt;what is inputted above&gt;</span><br></pre></td></tr></table></figure><p>fork 和 exec 分离的一个好处就是 shell 可以在 fork 和 exec 之间优雅实现重定向，如上面的程序。如果把二者合并，提供一个 <code>forkexec</code>  系统调用，重定向的实现就很烦了：需要多传参数；或者在调用 forkexec 前设置 shell 进程自己的描述符，然后又改回去；或者让每个程序自己去支持重定向。</p><h2 id="共享偏移"><a href="#共享偏移" class="headerlink" title="共享偏移"></a>共享偏移</h2><p>fork 的时候会拷贝文件描述符表，但每个文件的偏移量（读&#x2F;写到哪）会在父子进程间共享。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usharedoffset.c</span></span><br><span class="line"><span class="comment">// Although fork copies the file descriptor table, each underlying file offset is shared between parent and child.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; output.txt</span><br><span class="line">$ usharedoffset &gt; output.txt</span><br><span class="line">$ <span class="built_in">cat</span> output.txt</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><p>dup “复制”一个现有的文件描述符，返回的新描述符指向和原来一样的 I&#x2F;O 物体（比如文件）。类似于 fork，新旧文件描述符共享 offset。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// udup.c</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The dup system call duplicates an existing file descriptor,</span></span><br><span class="line"><span class="comment">// returning a new one that refers to the same underlying I/O object.</span></span><br><span class="line"><span class="comment">// Both file descriptors share an offset, just as the file descriptors</span></span><br><span class="line"><span class="comment">// duplicated by fork do.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ udup &gt; output.txt</span><br><span class="line">$ <span class="built_in">cat</span> output.txt</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>利用 dup，shell 就可以实现 <code>ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1</code> 了。 <code>2&gt;&amp;1</code> 就是 <code>2 = dup(1)</code>，让标准错误和标准输出指向同一个文件，并且共享偏移（一直往后写）。</p><hr><p>EOF</p><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># By CDFMLR 2021-02-18</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;See you.🧑‍💻&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL- Databases and Tables(1)</title>
      <link href="/Blog/2021/09/20/MySQL/MySQL/"/>
      <url>/Blog/2021/09/20/MySQL/MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>This article is general commands of MySQL in database and table operations. The structure follows the course content of <a href="https://www.udemy.com/course/the-ultimate-mysql-bootcamp-go-from-sql-beginner-to-expert/">The Ultimate MySQL Bootcamp: Go from SQL Beginner to Expert</a>. The article only cover the basic SQL key words. More articles on searching, inter-table relation will be posted later.</p><p> Note: SQL language is case insensitive, however commands and function characters are usually written in uppercase just for easier reading.</p><h2 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h2><p>Database commands:  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># creation <span class="operator">&amp;</span> deletion</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="operator">&lt;</span>db_name<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">DROP</span> DATABASE <span class="operator">&lt;</span>db_name<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">check</span> <span class="keyword">all</span> database <span class="operator">&amp;</span> the currently being used</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"></span><br><span class="line"># switch <span class="keyword">into</span> a database</span><br><span class="line">USE <span class="operator">&lt;</span>db_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h2 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h2><h3 id="Creation-amp-Deletion"><a href="#Creation-amp-Deletion" class="headerlink" title="Creation &amp; Deletion"></a>Creation &amp; Deletion</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># creation <span class="operator">&amp;</span> deletion</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span></span><br><span class="line">  (</span><br><span class="line">    column_name1 dataType(size),</span><br><span class="line">    column_name2 dataType(size)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">check</span> Tables</span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="keyword">DESC</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span>; # Descibe the <span class="keyword">table</span> format</span><br></pre></td></tr></table></figure><h3 id="Data-format"><a href="#Data-format" class="headerlink" title="Data format"></a>Data format</h3><p>While creating a table, three settings of the data are commonly considered: default value, $NULL$ or $NOT  NULL$ and entry id. An example is as below to explain:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cats</span><br><span class="line">  (</span><br><span class="line">    cat_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    cat_name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;Unknown&#x27;</span>,</span><br><span class="line">    age <span class="type">INT</span></span><br><span class="line">  );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cats (cat_name, age)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Kate&#x27;</span>, <span class="number">26</span>),</span><br><span class="line">(<span class="string">&#x27;Ron&#x27;</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>Data type in SQL language:</p><table><thead><tr><th align="left">名称</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">INT</td><td align="left">整型</td><td align="left">4字节整数类型，范围约+&#x2F;-21亿</td></tr><tr><td align="left">BIGINT</td><td align="left">长整型</td><td align="left">8字节整数类型，范围约+&#x2F;-922亿亿</td></tr><tr><td align="left">REAL</td><td align="left">浮点型</td><td align="left">4字节浮点数，范围约+&#x2F;-1038</td></tr><tr><td align="left">DOUBLE</td><td align="left">浮点型</td><td align="left">8字节浮点数，范围约+&#x2F;-10308</td></tr><tr><td align="left">DECIMAL(M,N)</td><td align="left">高精度小数</td><td align="left">由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算</td></tr><tr><td align="left">CHAR(N)</td><td align="left">定长字符串</td><td align="left">存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串</td></tr><tr><td align="left">VARCHAR(N)</td><td align="left">变长字符串</td><td align="left">存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串</td></tr><tr><td align="left">BOOLEAN</td><td align="left">布尔类型</td><td align="left">存储True或者False</td></tr><tr><td align="left">DATE</td><td align="left">日期类型</td><td align="left">存储日期，例如，2018-06-22</td></tr><tr><td align="left">TIME</td><td align="left">时间类型</td><td align="left">存储时间，例如，12:20:59</td></tr><tr><td align="left">DATETIME</td><td align="left">日期和时间类型</td><td align="left">存储日期+时间，例如，2018-06-22 12:20:59</td></tr></tbody></table><h3 id="Make-Changes"><a href="#Make-Changes" class="headerlink" title="Make Changes"></a>Make Changes</h3><p>Now we have some data in the table but we want to do changes:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">delete</span> a <span class="keyword">column</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> cats</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>column_name<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">update</span> <span class="keyword">some</span> <span class="keyword">values</span></span><br><span class="line"><span class="keyword">UPDATE</span> cats <span class="keyword">SET</span> age <span class="operator">=</span> <span class="number">100</span> <span class="keyword">WHERE</span> <span class="operator">&lt;</span>conditions<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"># conditional Deletion</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> cats <span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> cats; # This will <span class="keyword">delete</span> <span class="keyword">all</span> data <span class="keyword">in</span> cats <span class="keyword">table</span></span><br></pre></td></tr></table></figure><p>We may also want to print&#x2F;see the data in the table (DESC is only for describing the structure of the table but the content):</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cats; # print <span class="keyword">all</span> Content</span><br><span class="line"><span class="keyword">SELECT</span> column_name1,column_name2 <span class="keyword">FROM</span> cats;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>column_name<span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">&lt;</span>conditions<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>Note: $SELECT$ is like a print function and can be combined with other entry functions to look in the table without changing it. Often we want to have the printed column name presented differently by using $AS$:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  column_name1 <span class="keyword">AS</span> c1,</span><br><span class="line">  column_name2 <span class="keyword">AS</span> c2</span><br><span class="line"><span class="keyword">FROM</span> cats;</span><br></pre></td></tr></table></figure><h2 id="String-functions"><a href="#String-functions" class="headerlink" title="String functions"></a>String functions</h2><p>After the general operations on database, tables we enter into entry operations. In this section we look into the five most popular string functions of MySQL.</p><p>To combine data:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONCAT(column_name1, <span class="string">&#x27; &#x27;</span>, column_name2);</span><br><span class="line">CONCAT_WS(<span class="string">&#x27;-&#x27;</span>,column_name1,column_name2);</span><br></pre></td></tr></table></figure><p>The second function above allows add in delimiter. To extract part of the string:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SUBSTRING</span>(<span class="string">&#x27;HELLO WORLD&#x27;</span>,<span class="number">1</span>,<span class="number">7</span>); # <span class="number">1</span> <span class="keyword">to</span> <span class="number">7</span></span><br><span class="line"><span class="built_in">SUBSTRING</span>(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">7</span>); # <span class="number">7</span> <span class="keyword">to</span> <span class="number">-1</span></span><br><span class="line"><span class="built_in">SUBSTRING</span>(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">-3</span>); # <span class="number">-3</span> <span class="keyword">to</span> <span class="number">-1</span></span><br><span class="line"># The same</span><br><span class="line">SUBSTR(<span class="string">&#x27;Hello World&#x27;</span>,<span class="number">-3</span>);</span><br></pre></td></tr></table></figure><p>To replace part of the string:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE(<span class="string">&#x27;Hello World&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;3&#x27;</span>);</span><br></pre></td></tr></table></figure><p>To reverse the string:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVERSE(<span class="string">&#x27;Hello World&#x27;</span>);</span><br></pre></td></tr></table></figure><p>To count the length of the string:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br></pre></td></tr></table></figure><p>To get the upper case or lower case:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPPER</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"><span class="built_in">LOWER</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
