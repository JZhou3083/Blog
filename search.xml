<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Validate Stack Sequences</title>
      <link href="/Blog/2022/07/11/ValidateStack/"/>
      <url>/Blog/2022/07/11/ValidateStack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考: <a href="https://leetcode.cn/problems/validate-stack-sequences/solution/yan-zheng-zhan-xu-lie-by-leetcode/">Validate Stack Sequences</a></p></blockquote><h1 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h1><p>Given two integer arrays $pushed$ and $popped$ each with distinct values, return $true$ if this could have been the result of a sequence of push and pop operations on an initially empty stack, or $false$ otherwise.</p><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We might do the following sequence:</span><br><span class="line">push(1), push(2), push(3), push(4),</span><br><span class="line">pop() -&gt; 4,</span><br><span class="line">push(5),</span><br><span class="line">pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: 1 cannot be popped before 2.</span><br></pre></td></tr></table></figure><p>Constraints:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 1 &lt;= pushed.length &lt;= 1000</span><br><span class="line">* 0 &lt;= pushed[i] &lt;= 1000</span><br><span class="line">* All the elements of pushed are unique.</span><br><span class="line">* popped.length == pushed.length</span><br><span class="line">* popped is a permutation of pushed</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>The problem uses Simulation method: create a empty stack and simulate the constructing process of $popped$ from $pushed$. Assuming successful construction, it is easy to notice that the number of \b{pop} operation should be the length of $popped$ no matter what the order is. The restrictions are, therefore, essential in the construction: the maximum number of \b{pop}; the numbers in $pushed$ can run out only once; Hence, at $i&#x3D;0,1,2…len(pushed)-1$ iteration, the $i_{th}$ number of the $pushed$ is pushed into the new stack. Then do the stack popping on while loop with the conditions:</p><ul><li>The new stack is not empty</li><li>The number of \b{pop} operation: $j$ hasn’t reached the length of $popped$</li><li>The number at the top of the new stack (the one that is just popped) equals to the $j_{th}$ number of $popped$. It has to be exactly the $j_{th}$ because the order of popped elements won’t match otherwise.</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python code</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">validateStackSequences</span>(<span class="params">self, pushed: <span class="type">List</span>[<span class="built_in">int</span>], popped: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">        new_stack = <span class="built_in">list</span>()</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        N = <span class="built_in">len</span>(pushed)</span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> pushed:</span><br><span class="line">            new_stack.append(num)</span><br><span class="line">            <span class="keyword">while</span> new_stack <span class="keyword">and</span> j&lt; N <span class="keyword">and</span> new_stack[-<span class="number">1</span>] == popped[j]:</span><br><span class="line">                new_stack.pop()</span><br><span class="line">                j+=<span class="number">1</span>      </span><br><span class="line">        <span class="keyword">return</span> j == N</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>This question tests the usage of stack structure and familiarize me with Simulation method.  </p>]]></content>
      
      
      
        <tags>
            
            <tag> Leedcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Calculator</title>
      <link href="/Blog/2022/07/10/Calculator/"/>
      <url>/Blog/2022/07/10/Calculator/</url>
      
        <content type="html"><![CDATA[<blockquote><small><i>设计一个计算器最头疼的就是中序后缀表达式中的括号，比如3+4x5 与 (3+4)x5 的计算顺序造成结果不一样。一个经典的解决办法就是将其转化成后缀表达式，也称逆波兰式。本文章是因为经常碰到设计计算器或者类似的题目，做一个总结来捋一捋。</i></small></blockquote><h2 id="Reverse-Polish-notation"><a href="#Reverse-Polish-notation" class="headerlink" title="Reverse Polish notation"></a>Reverse Polish notation</h2><p>The idea of Reverse Polish notation is to convert the infix notation into a format of:<br>$$ (Num_{left})\ (Num_{right})\ Ops $$<br>and maintain that for the whole expression. Where there are consecutive operands, the operand with higher priority goes first. For instance:<br>$$ 3-4\times 5 &#x3D;&gt; 3\quad4\quad5\times- $$<br>and conversely:<br>$$ (3-4)\times 5 &#x3D;&gt; 3\quad4 - 5\times\quad$$<br>Later in the calculating, whenever the program read a operand from the postfix expression, it pops out the previous two numbers, calculate with the operand and push the result back to the stack. Eventually, the last number left in the stack will be the result of the equation.</p><h2 id="Infix-to-Postfix"><a href="#Infix-to-Postfix" class="headerlink" title="Infix to Postfix"></a>Infix to Postfix</h2><p>So we know how Reverse Polish notation can be useful. What’s next is how to generate it from infix expression. Let’s start from the easy part where there aren’t any brackets. In such case, the converter only cares about the priority:</p><ul><li>‘*’ and ‘&#x2F;‘ have higher priority than ‘+’ and ‘-‘</li><li>When the priorities are equal, operand on the left has higher priority</li></ul><p>Hence, create stacks $\color{red}{ops}$ to store the operands and $\color{green}{out}$, read chars from the infix expression:</p><ul><li>If a char is a number, push it into $\color{green}{out}$</li><li>If a char is a operand, compare it with the operand at the top of the $\color{red}{ops}$:<ul><li>If it has higher priority, push it into $\color{red}{ops}$</li><li>If it has lower or equal priority, pop a operand from $\color{red}{ops}$ and push it into $\color{green}{out}$ until finding the next ‘higher’ operand. Then push the new char into<br>$$\color{red}{ops}$.</li></ul></li><li>When the iteration on Infix expression finish, pop what’s left in $\color{red}{ops}$ and push into $\color{green}{out}$.</li></ul><p>Now brings in the brackets, what it does is simply making a mark for ‘coming back’ that functions as the ‘higher’ operand. That is, when the char is ‘)’, the $\color{red}{ops}$ keeps popping elements and pushing them into $\color{green}{out}$ until it pops out the nearest ‘(‘. To avoid ‘(‘ from disrupting other operands’ popping, the priority of ‘(‘ is set to be the lowest. Note: No need to set ‘)’ priority because it will never be pushed into the stack.</p><p>Example:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python code</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">infixToPost</span>(<span class="params">s</span>):</span><br><span class="line">    level = &#123;&#125;</span><br><span class="line">    level[<span class="string">&#x27;*&#x27;</span>] = <span class="number">3</span></span><br><span class="line">    level[<span class="string">&#x27;/&#x27;</span>] = <span class="number">3</span></span><br><span class="line">    level[<span class="string">&#x27;+&#x27;</span>] = <span class="number">2</span></span><br><span class="line">    level[<span class="string">&#x27;-&#x27;</span>] = <span class="number">2</span></span><br><span class="line">    level[<span class="string">&#x27;(&#x27;</span>] = <span class="number">1</span></span><br><span class="line">    nums = <span class="string">&#x27;0123456789&#x27;</span></span><br><span class="line">    ops = <span class="string">&#x27;()+-*/&#x27;</span></span><br><span class="line">    out = <span class="built_in">list</span>()</span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> nums:</span><br><span class="line">            out.append(c)</span><br><span class="line">        <span class="keyword">elif</span> c <span class="keyword">in</span> ops:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">while</span> (sign := stack.pop()) != <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    out.append(sign)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> level[stack[-<span class="number">1</span>]] &gt;= level[c]:</span><br><span class="line">                    out.append(stack.pop())</span><br><span class="line">                stack.append(c)</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        out.append(stack.pop())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(out)</span><br></pre></td></tr></table></figure><h2 id="Calculation"><a href="#Calculation" class="headerlink" title="Calculation"></a>Calculation</h2><p>The idea has been explained in the previous section:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># calculation</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">postfix_eval</span>(<span class="params">postfix_expr</span>):</span><br><span class="line">    operand_stack =Stack()</span><br><span class="line">    postfix_list = postfix_expr.split()</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> postfix_list:</span><br><span class="line">        <span class="keyword">if</span> token.isnumeric():</span><br><span class="line">            operand_stack.push(<span class="built_in">int</span>(token))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            top_operand2 = operand_stack.pop()</span><br><span class="line">            top_operand1 = operand_stack.pop()</span><br><span class="line">            result = do_math(token,top_operand1,top_operand2)</span><br><span class="line">            operand_stack.push(result)</span><br><span class="line">    <span class="keyword">return</span> operand_stack.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace the string to operator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_math</span>(<span class="params">op, op1, op2</span>):</span><br><span class="line">    <span class="keyword">if</span> op == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1+op2</span><br><span class="line">    <span class="keyword">elif</span> op==<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1-op2</span><br><span class="line">    <span class="keyword">elif</span> op==<span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1*op2</span><br><span class="line">    <span class="keyword">elif</span> op==<span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1/op2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Practice-Leedcode-224"><a href="#Practice-Leedcode-224" class="headerlink" title="Practice: Leedcode 224"></a>Practice: Leedcode 224</h2><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. Example 1: s &#x3D; “1 + 1”, output: 2; Example 2: s &#x3D; “2 -1 + 2”, output: 3; Example 3: s &#x3D; “(1+(4+5+2)-3)+(6+8)” , output: 23.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>As there are only addition and subtraction, no need to consider the priority but only the brackets. The idea is to keep track of the result from the left equation, the sign (+&#x2F;-) and the number as the right equation (similar to postfix). When the program read ‘(‘, it stack the res and sign, then reset them as 0s to tackle the equation inside the bracket as a new equation:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">s</span>):</span><br><span class="line">    res, num, sign = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c.isdigit():</span><br><span class="line">            num = <span class="number">10</span> * num +<span class="built_in">int</span>(c)</span><br><span class="line">        <span class="keyword">elif</span> c ==<span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c ==<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            res = res + sign*num</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            sign = <span class="number">1</span> <span class="keyword">if</span> c ==<span class="string">&#x27;+&#x27;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            stack.append(res)</span><br><span class="line">            stack.append(sign)</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            res += sign*num</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            res *= stack.pop()</span><br><span class="line">            res += stack.pop()</span><br><span class="line">    res += sign * num</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>简而言之，计算器的关键是要用栈来构建后缀表达式。在后缀表达式中，先使用的计算符会放在前面，保证计算过程中会被先执行。而构建后缀的方法则是创建一个操作符栈，每当新的符号优先级低于操作符栈顶端的符号，则会弹出栈里面的优先级别大于或等于新符号的所有操作符，并放进输出。与此同时，类似的如果新的操作符是右括号，则会弹出并压入输出栈所有在左括号上方的所有符号，依次压入输出栈。迭代完后，把操作符栈剩下的符号以此弹出压入输出。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>Wikipedia. Reverse Polish notation. <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation#Explanation">https://en.wikipedia.org/wiki/Reverse_Polish_notation#Explanation</a></li><li>Leedcode. Basic calculator. <a href="https://leetcode.cn/problems/basic-calculator/">https://leetcode.cn/problems/basic-calculator/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
            <tag> Leedcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xv6 Lab Utilities</title>
      <link href="/Blog/2022/07/08/Xv6-Lab-Utilities/"/>
      <url>/Blog/2022/07/08/Xv6-Lab-Utilities/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考: <a href="https://clownote.github.io/2021/02/24/xv6/Xv6-Lab-Utilities/">Lab: Xv6 and Unix utilities</a></p></blockquote><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>Implement the UNIX program <code>sleep</code> for xv6; your <code>sleep</code> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p><p>Some hints:</p><ul><li>Before you start coding, read Chapter 1 of the <a href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">xv6 book</a>.</li><li>Look at some of the other programs in <code>user/</code> (e.g., <code>user/echo.c</code>, <code>user/grep.c</code>, and <code>user/rm.c</code>) to see how you can obtain the command-line arguments passed to a program.</li><li>If the user forgets to pass an argument, sleep should print an error message.</li><li>The command-line argument is passed as a string; you can convert it to an integer using <code>atoi</code> (see user&#x2F;ulib.c).</li><li>Use the system call <code>sleep</code>.</li><li>See <code>kernel/sysproc.c</code> for the xv6 kernel code that implements the <code>sleep</code> system call (look for <code>sys_sleep</code>), <code>user/user.h</code> for the C definition of <code>sleep</code> callable from a user program, and <code>user/usys.S</code> for the assembler code that jumps from user code into the kernel for <code>sleep</code>.</li><li>Make sure <code>main</code> calls <code>exit()</code> in order to exit your program.</li><li>Add your <code>sleep</code> program to <code>UPROGS</code> in Makefile; once you’ve done that, <code>make qemu</code> will compile your program and you’ll be able to run it from the xv6 shell.</li><li>Look at Kernighan and Ritchie’s book <em>The C programming language (second edition)</em> (K&amp;R) to learn about C.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ticks;  <span class="comment">// time to sleep</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: sleep ticks\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ticks = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  sleep(ticks);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>build &amp; run:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ <span class="built_in">sleep</span> 10</span><br><span class="line">(nothing happens <span class="keyword">for</span> a little <span class="keyword">while</span>)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<code>&lt;pid&gt;: received ping</code>“, where <code>&lt;pid&gt;</code> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<code>&lt;pid&gt;: received pong</code>“, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</p><p>Some hints:</p><ul><li>Use <code>pipe</code> to create a pipe.</li><li>Use <code>fork</code> to create a child.</li><li>Use <code>read</code> to read from the pipe, and <code>write</code> to write to the pipe.</li><li>Use <code>getpid</code> to find the process ID of the calling process.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li><li>User programs on xv6 have a limited set of library functions available to them. You can see the list in <code>user/user.h</code>; the source (other than for system calls) is in <code>user/ulib.c</code>, <code>user/printf.c</code>, and <code>user/umalloc.c</code>.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p[<span class="number">2</span>];  <span class="comment">// file descriptors for pipe</span></span><br><span class="line"><span class="type">char</span> recv_buf[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">pipe(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// child</span></span><br><span class="line">read(p[<span class="number">0</span>], recv_buf, <span class="number">4</span>);</span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>, getpid(), recv_buf);</span><br><span class="line"></span><br><span class="line">write(p[<span class="number">1</span>], <span class="string">&quot;pong&quot;</span>, <span class="number">4</span>);</span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// parent</span></span><br><span class="line">write(p[<span class="number">1</span>], <span class="string">&quot;ping&quot;</span>, <span class="number">4</span>);</span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">read(p[<span class="number">0</span>], recv_buf, <span class="number">4</span>);</span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>, getpid(), recv_buf);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ pingpong</span><br><span class="line">4: received ping</span><br><span class="line">3: received pong</span><br></pre></td></tr></table></figure><h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p><p>Your goal is to use <code>pipe</code> and <code>fork</code> to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35.</p><p>Some hints:</p><ul><li>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</li><li>Once the first process reaches 35, it should wait until the entire pipeline terminates, including all children, grandchildren, &amp;c. Thus the main primes process should only exit after all the output has been printed, and after all the other primes processes have exited.</li><li>Hint: <code>read</code> returns zero when the write-side of a pipe is closed.</li><li>It’s simplest to directly write 32-bit (4-byte) <code>int</code>s to the pipes, rather than using formatted ASCII I&#x2F;O.</li><li>You should create the processes in the pipeline only as they are needed.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li></ul><p>例程1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_PRIME 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">generate_natural</span><span class="params">()</span>;  <span class="comment">// -&gt; out_fd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">prime_filter</span><span class="params">(<span class="type">int</span> in_fd, <span class="type">int</span> prime)</span>;  <span class="comment">// -&gt; out_fd</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> prime;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> in = generate_natural();</span><br><span class="line"><span class="keyword">while</span> (read(in, &amp;prime, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line"><span class="comment">// printf(&quot;prime %d: in_fd: %d\n&quot;, prime, in);  // debug</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">in = prime_filter(in, prime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成自然数: 2, 3, 4, ..&lt; MAX</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">generate_natural</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> out_pipe[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">pipe(out_pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = FIRST_PRIME; i &lt; MAX; i++) &#123;</span><br><span class="line">write(out_pipe[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line">close(out_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(out_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out_pipe[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 素数筛</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">prime_filter</span><span class="params">(<span class="type">int</span> in_fd, <span class="type">int</span> prime)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span> out_pipe[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">pipe(out_pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line"><span class="keyword">while</span> (read(in_fd, &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (num % prime) &#123;</span><br><span class="line">write(out_pipe[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(in_fd);</span><br><span class="line">close(out_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(in_fd);</span><br><span class="line">close(out_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out_pipe[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序是参考 《<a href="https://chai2010.cn/advanced-go-programming-book/">Go语言高级编程</a>》<a href="https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-06-goroutine.html">1.6 常见的并发模式</a> 中的那个 Golang 版本写的。Golang 的并发模型和 UNIX Pipe 本身就很像（refer: <a href="https://golang.google.cn/doc/effective_go#sharing">Effective Go: Share by communicating</a>），这里只需把 chan 换成 pipe，Goroutine 换成 fork 的进程。但是，一定要、一定要、一定要注意那些在子进程中使用的文件描述符，父进程不用就要关了，不然就凉了。</p><p>例程2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">source</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="keyword">for</span> (num=<span class="number">2</span>;num&lt;<span class="number">35</span>;num++)&#123;</span><br><span class="line">write(<span class="number">1</span>,&amp;num, <span class="keyword">sizeof</span>(num));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">filter</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line"><span class="type">int</span> n ;</span><br><span class="line"><span class="keyword">while</span>(read(<span class="number">0</span>,&amp;n,<span class="keyword">sizeof</span>(n)))&#123;</span><br><span class="line"><span class="keyword">if</span> (n%p !=<span class="number">0</span>)&#123;write(<span class="number">1</span>,&amp;n,<span class="keyword">sizeof</span>(n));&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">redirect</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> pd[])</span>&#123;</span><br><span class="line">close(k);</span><br><span class="line">dup(pd[k]);</span><br><span class="line">close(pd[<span class="number">0</span>]);</span><br><span class="line">close(pd[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sink</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> pd[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line"><span class="keyword">if</span>(read(<span class="number">0</span>,&amp;p,<span class="keyword">sizeof</span>(p)))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;prime: %d\n&quot;</span>, p);</span><br><span class="line">pipe(pd);</span><br><span class="line"><span class="keyword">if</span>(fork())&#123;</span><br><span class="line">redirect(<span class="number">0</span>,pd);</span><br><span class="line">sink();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">redirect(<span class="number">1</span>,pd);</span><br><span class="line">filter(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> pd[<span class="number">2</span>];</span><br><span class="line">pipe(pd);</span><br><span class="line"><span class="keyword">if</span>(fork()&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// parent process redirects the standard input to pd[0]</span></span><br><span class="line">redirect(<span class="number">0</span>,pd);</span><br><span class="line">sink();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//child process redirect the standard ouput to pd[1]</span></span><br><span class="line">redirect(<span class="number">1</span>, pd);</span><br><span class="line">source();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>运行·结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ primes</span><br><span class="line">prime 2</span><br><span class="line">prime 3</span><br><span class="line">prime 5</span><br><span class="line">prime 7</span><br><span class="line">prime 11</span><br><span class="line">prime 13</span><br><span class="line">prime 17</span><br><span class="line">prime 19</span><br><span class="line">prime 23</span><br><span class="line">prime 29</span><br><span class="line">prime 31</span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file <code>user/find.c</code>.</p><p>Some hints:</p><ul><li>Look at user&#x2F;ls.c to see how to read directories.</li><li>Use recursion to allow find to descend into sub-directories.</li><li>Don’t recurse into “.” and “..”.</li><li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li><li>You’ll need to use C strings. Have a look at K&amp;R (the C book), for example Section 5.5.</li><li>Note that &#x3D;&#x3D; does not compare strings like in Python. Use strcmp() instead.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find first character after last slash.</span></span><br><span class="line"><span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">;</span><br><span class="line">p++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *targetname)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(fmtname(path), targetname)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open [%s], fd=%d\n&quot;</span>, path, fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (st.type != T_DIR) &#123;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// st.type == T_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">*p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line"><span class="keyword">if</span> (de.inum == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">memmove(p, de.name, DIRSIZ);</span><br><span class="line">p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">find(buf, targetname);</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: find path filename\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是抄 <code>user/ls.c</code>。这个指针玩的，，太骚了[捂脸]: $path$被复制到$buf$，然后创建一个指针$*p$指向$buf$的首字符地址，后面加一个“&#x2F;”，接着把$p$递增指向下一位。这样做有什么好处呢，之后只需要不停从fd读取文件名，此处$de$是$dirent$，是文件标志符的基本单元，定义在$“kernel&#x2F;fs.h”$中。然后不断把$de.name$通过$memmove$这个函数赋值给指针$p$。然后从$buf$的首地址读取会得到当前文件的全地址。同时该函数用到了递归，知道吧目标路径和其所有子路径的文件都对比一遍，发现目标文件名则输出全地址，否则查完收工。 </p><p>结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &gt; b</span><br><span class="line">$ <span class="built_in">mkdir</span> a</span><br><span class="line">$ <span class="built_in">echo</span> &gt; a/b</span><br><span class="line">$ find . b</span><br><span class="line">./b</span><br><span class="line">./a/b</span><br></pre></td></tr></table></figure><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p><p>The following example illustrates xarg’s behavior:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello too | xargs <span class="built_in">echo</span> <span class="built_in">bye</span></span><br><span class="line"><span class="built_in">bye</span> hello too</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>Note that the command here is “echo bye” and the additional arguments are “hello too”, making the command “echo bye hello too”, which outputs “bye hello too”.</p><p>Please note that xargs on UNIX makes an optimization where it will feed more than argument to the command at a time. We don’t expect you to make this optimization. To make xargs on UNIX behave the way we want it to for this lab, please run it with the -n option set to 1. For instance</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;1\n2&quot;</span> | xargs -n 1 <span class="built_in">echo</span> line</span><br><span class="line">line 1</span><br><span class="line">line 2</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>Some hints:</p><ul><li>Use <code>fork</code> and <code>exec</code> to invoke the command on each line of input. Use <code>wait</code> in the parent to wait for the child to complete the command.</li><li>To read individual lines of input, read a character at a time until a newline (‘\n’) appears.</li><li>kernel&#x2F;param.h declares MAXARG, which may be useful if you need to declare an argv array.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li><li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li></ul><p>xargs, find, and grep combine well:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . b | xargs grep hello</span><br></pre></td></tr></table></figure><p>will run “grep hello” on each file named b in the directories below “.”.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span>  <span class="comment">// MAXARG</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> is_blank(chr) (chr == <span class="string">&#x27; &#x27;</span> || chr == <span class="string">&#x27;\t&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">2048</span>], ch;</span><br><span class="line"><span class="type">char</span> *p = buf;</span><br><span class="line"><span class="type">char</span> *v[MAXARG];</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="type">int</span> blanks = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: xargs &lt;command&gt; [argv...]\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">1</span>; c &lt; argc; c++) &#123;</span><br><span class="line">v[c<span class="number">-1</span>] = argv[c];</span><br><span class="line">&#125;</span><br><span class="line">--c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (read(<span class="number">0</span>, &amp;ch, <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_blank(ch)) &#123;</span><br><span class="line">blanks++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (blanks) &#123;  <span class="comment">// 之前有过空格</span></span><br><span class="line">buf[offset++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">v[c++] = p;</span><br><span class="line">p = buf + offset;</span><br><span class="line"></span><br><span class="line">blanks = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ch != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">buf[offset++] = ch;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">v[c++] = p;</span><br><span class="line">p = buf + offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line"><span class="built_in">exit</span>(exec(v[<span class="number">0</span>], v));</span><br><span class="line">&#125;</span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">c = argc - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是字符串操作麻烦。。</p><p>运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello too | xargs <span class="built_in">echo</span> <span class="built_in">bye</span></span><br><span class="line"><span class="built_in">bye</span> hello too</span><br><span class="line">$ find . b</span><br><span class="line">./b</span><br><span class="line">./a/b</span><br><span class="line">$ find . b | xargs <span class="built_in">echo</span> hello</span><br><span class="line">hello ./b</span><br><span class="line">hello ./a/b</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>MIT. Lab guidance. <a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html</a></li><li>MIT. Lab: Xv6 and Unix utilities. <a href="https://pdos.csail.mit.edu/6.S081/2020/labs/util.html">https://pdos.csail.mit.edu/6.S081/2020/labs/util.html</a></li><li>KatyuMarisa. MIT 6.S081 xv6调试不完全指北. <a href="https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html">https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html</a></li><li>lhw–9999. xv6操作系统实验 – 质数筛. <a href="https://blog.csdn.net/lhwhit/article/details/108342724">https://blog.csdn.net/lhwhit/article/details/108342724</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Xv6 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
