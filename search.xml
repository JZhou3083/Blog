<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Bubble Sort</title>
      <link href="/Blog/2022/07/25/bubbleSort/"/>
      <url>/Blog/2022/07/25/bubbleSort/</url>
      
        <content type="html"><![CDATA[<h1 id="Bubble-Sort"><a href="#Bubble-Sort" class="headerlink" title="Bubble Sort"></a>Bubble Sort</h1><p>The method is easy to understand: it repeatedly iterate the array and compares the coherent two elements. If the order of the two elements conflicts with the requirement, switch their positions. The name is because the maximum values will gradually bubble out to the end of the array.</p><h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><ol><li>Compare the neighbor elements, if the first element is greater, switch the position.</li><li>Continue the step 1 until the maximum element bubbles to the end, this element is considered sorted and will not join the comparing any more.</li><li>Repeated step 1 and step 2 and the number of sorted elements at the end increments by 1 every time, until all elements are sorted</li></ol><h1 id="GIF-Demonstration"><a href="#GIF-Demonstration" class="headerlink" title="GIF Demonstration"></a>GIF Demonstration</h1><p><img src="https://github.com/hustcc/JS-Sorting-Algorithm/blob/master/res/bubbleSort.gif?raw=true" alt="GIF"></p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubbleSort</span>(<span class="params">arr</span>):</span><br><span class="line">  N = <span class="built_in">len</span>(arr)</span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,N):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N-<span class="number">1</span>):</span><br><span class="line">      <span class="keyword">if</span> arr[j] &gt; arr[j+<span class="number">1</span>]:</span><br><span class="line">        arr[j], arr[j+<span class="number">1</span>] = arr[j+<span class="number">1</span>], arr[j] <span class="comment"># switch</span></span><br><span class="line">  <span class="keyword">return</span> arr</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sorting</title>
      <link href="/Blog/2022/07/24/Sorting/"/>
      <url>/Blog/2022/07/24/Sorting/</url>
      
        <content type="html"><![CDATA[<blockquote><p>[参考]（<a href="https://github.com/hustcc/JS-Sorting-Algorithm.git%EF%BC%89">https://github.com/hustcc/JS-Sorting-Algorithm.git）</a></p></blockquote><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>排序算法是数据结构和算法中最基本的算法之一，最常碰见的包括：冒泡排序，选择排序，插入排序，归并排序，快速排序，堆排序，基数排序，希尔排序等。 用一张图概括：</p><p><img src="https://raw.githubusercontent.com/hustcc/JS-Sorting-Algorithm/master/res/sort.png" alt="sort"></p><h1 id="Time-Complexity"><a href="#Time-Complexity" class="headerlink" title="Time Complexity"></a>Time Complexity</h1><ol><li>$O(n^2)$: Bubble Sort, Selection Sort and Insertion Sort.</li><li>$O(nlog_2n)$: Quick Sort, Heap Sort and Merge Sort</li><li>$O(n^{1+{\theta}} )$ where ${\theta} \in [0,1]$ between 0 and 1: Shell Sort</li><li>$O(n)$ Radix Sort<br>and Bucket Sort</li></ol><h1 id="Stability"><a href="#Stability" class="headerlink" title="Stability"></a>Stability</h1><ul><li>Stable: Bubble Sort, Insertion Sort, Merge Sort and Radix Sort</li><li>Unstable: Selection Sort, Quick Sort, Shell Sort, Heap Sort</li></ul><hr><ol><li><a href="bubbleSort.md">冒泡排序</a></li><li><a href="2.selectionSort.md">选择排序</a></li><li><a href="3.insertionSort.md">插入排序</a></li><li><a href="4.shellSort.md">希尔排序</a></li><li><a href="5.mergeSort.md">归并排序</a></li><li><a href="6.quickSort.md">快速排序</a></li><li><a href="7.heapSort.md">堆排序</a></li><li><a href="8.countingSort.md">计数排序</a></li><li><a href="9.bucketSort.md">桶排序</a></li><li><a href="10.radixSort.md">基数排序</a></li></ol><hr>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL- Search</title>
      <link href="/Blog/2022/07/23/MySQL/MySQL-Search/"/>
      <url>/Blog/2022/07/23/MySQL/MySQL-Search/</url>
      
        <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>This article lists the most common key words for the entry searching in MySQL table, covering from conditional language, to logical operators.</p><h2 id="Conditions"><a href="#Conditions" class="headerlink" title="Conditions"></a>Conditions</h2><p>If you want to print of the entries with unique columns:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">DISTINCT</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column_name <span class="keyword">FROM</span> tb_name;</span><br></pre></td></tr></table></figure><p>Ordering the items according specific column:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column_name</span><br><span class="line"><span class="keyword">FROM</span> tb_name  </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name1;</span><br></pre></td></tr></table></figure><p>If you only want part of the entries:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> column_name</span><br><span class="line"><span class="keyword">FROM</span> tb_name</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name2 <span class="keyword">DESC</span><span class="operator">/</span><span class="keyword">ASC</span> LIMIT <span class="operator">&lt;</span>NUM_STATR, NUM_OF_ROWS<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>To perform vague searching, use LIKE with ‘%’:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> column_name <span class="keyword">LIKE</span> <span class="string">&#x27;%Mike%&#x27;</span>;</span><br></pre></td></tr></table></figure><p>For searching that specifies the length of the string, use underscore ‘_’:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> stock_quantity <span class="keyword">LIKE</span> <span class="string">&#x27;____&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="Aggregate-Functions"><a href="#Aggregate-Functions" class="headerlink" title="Aggregate Functions"></a>Aggregate Functions</h2><p>To count the number of entries, use COUNT:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> author_lname <span class="operator">=</span><span class="string">&#x27;Gaiman&#x27;</span>;</span><br></pre></td></tr></table></figure><p>Sometime if we want to group the entries according to to part of their property, we use GROUP BY:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, author_lname, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> books <span class="keyword">GROUP</span> <span class="keyword">BY</span> author_lname,author_fname;</span><br></pre></td></tr></table></figure><p>GROUP BY often is combined with other operations to this specific group.</p><p>To sum up and average the numbers, use SUM:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(released_year)</span><br><span class="line"><span class="keyword">FROM</span> books;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(released_year)</span><br><span class="line"><span class="keyword">FROM</span> books;</span><br></pre></td></tr></table></figure><h2 id="Date-and-Time"><a href="#Date-and-Time" class="headerlink" title="Date and Time"></a>Date and Time</h2><p>The most commonly used:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">## These <span class="keyword">no</span> need args</span><br><span class="line">CURDATE();</span><br><span class="line">CURTIME();</span><br><span class="line">NOW();</span><br><span class="line">## These <span class="keyword">are</span> <span class="keyword">for</span> extracting</span><br><span class="line"><span class="keyword">DAY</span>(DateType);</span><br><span class="line">DAYOFNAME(DateType); ## <span class="keyword">return</span> Monday, ..</span><br><span class="line">DAYOFWEEK(DateType); ## <span class="keyword">return</span> the index <span class="keyword">of</span> the <span class="keyword">day</span></span><br><span class="line">DAYOFYEAR(DateType); <span class="keyword">return</span> index</span><br><span class="line"><span class="keyword">HOUR</span>();</span><br><span class="line"><span class="keyword">MINUTE</span>();</span><br></pre></td></tr></table></figure><p>A more convenient function is DATE_FORMAT():</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATE_FORMAT(birthday, <span class="string">&#x27;%W&#x27;</span>)</span><br><span class="line"><span class="keyword">FROM</span> people;</span><br></pre></td></tr></table></figure><p>W means the Monday,etc. For more indicators, check the official manual.</p><p>$TIMESTAMP$ is a specific type for time data:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">timestamp</span> <span class="keyword">DEFAULT</span> NOW() <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span><span class="operator">/</span>NOW();</span><br></pre></td></tr></table></figure><h2 id="Logical-Operators"><a href="#Logical-Operators" class="headerlink" title="Logical Operators"></a>Logical Operators</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">## <span class="keyword">not</span> equal</span><br><span class="line"><span class="operator">!=</span> 或者 <span class="keyword">NOT</span>;</span><br><span class="line">## greater<span class="operator">/</span>smaller<span class="operator">/</span>equal</span><br><span class="line"><span class="operator">&gt;</span> <span class="operator">&lt;</span>  <span class="operator">=</span>;</span><br><span class="line"><span class="keyword">AND</span> 或者 <span class="operator">&amp;&amp;</span>;</span><br><span class="line"><span class="keyword">OR</span> 或者 <span class="operator">||</span>;</span><br><span class="line"><span class="keyword">BETWEEN</span> x <span class="keyword">AND</span> y;</span><br><span class="line"><span class="keyword">IN</span> 和 <span class="keyword">NOT</span> <span class="keyword">IN</span>;</span><br><span class="line">## modulo <span class="operator">%</span></span><br><span class="line"><span class="keyword">SELECT</span> title,author_lname <span class="keyword">FROM</span> books <span class="keyword">WHERE</span> author_lname <span class="keyword">IN</span>(<span class="string">&#x27;CHARLES&#x27;</span>,<span class="string">&#x27;GAIMAN&#x27;</span>) <span class="keyword">and</span> released_year <span class="operator">%</span> <span class="number">2</span><span class="operator">!=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>A little complex is case statement:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, released_year,</span><br><span class="line">  <span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> released_year<span class="operator">&gt;=</span><span class="number">2000</span> <span class="keyword">THEN</span> <span class="string">&#x27;modern LIT&#x27;</span></span><br><span class="line">    <span class="keyword">WHEN</span> condition2 <span class="keyword">THEN</span> result2</span><br><span class="line">    <span class="keyword">ELSE</span> result2</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">&#x27;genre&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> books;</span><br></pre></td></tr></table></figure><p>If we want to group the entries by the authors and get the number of their books or book:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title, author_lname,</span><br><span class="line">  <span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="operator">=</span> <span class="number">1</span> <span class="keyword">THEN</span> <span class="string">&#x27;1 book&#x27;</span></span><br><span class="line">    <span class="keyword">ELSE</span> CONCAT(<span class="built_in">COUNT</span>(<span class="operator">*</span>), <span class="string">&#x27; books&#x27;</span>)</span><br><span class="line">  <span class="keyword">END</span> <span class="keyword">AS</span> <span class="string">&#x27;counts&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> books</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> author_lname;</span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>This article lists the basic operation within a table with conditional commands. In future article, more complex commands dealing with inter-table relationships will be summarized. </p>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xv6 Operating System Organization</title>
      <link href="/Blog/2022/07/18/Xv6/Organization/"/>
      <url>/Blog/2022/07/18/Xv6/Organization/</url>
      
        <content type="html"><![CDATA[<h1 id="Operating-System-Organization"><a href="#Operating-System-Organization" class="headerlink" title="Operating System Organization"></a>Operating System Organization</h1><blockquote><p>参考  <a href="https://github.com/mit-pdos/xv6-riscv-book">xv6-riscv-book</a> Chapter 2 Operating system organization</p></blockquote><p>Three requirements for OS:</p><ul><li>multiplexing</li><li>isolation</li><li>interaction</li></ul><h2 id="Abstracting-physical-resources"><a href="#Abstracting-physical-resources" class="headerlink" title="Abstracting physical resources"></a>Abstracting physical resources</h2><blockquote><p>Transparency: simplifies interaction</p></blockquote><ul><li>Abstract the resources into services</li><li>Applications don’t have to be aware of time sharing</li><li>Allows the OS to decide the usage of memory</li></ul><h2 id="User-mode-supervisor-mode-and-system-calls"><a href="#User-mode-supervisor-mode-and-system-calls" class="headerlink" title="User mode, supervisor mode, and system calls"></a>User mode, supervisor mode, and system calls</h2><p><img src="/Blog/.io//Xv6-operating-system-organization/kernel.png" alt="A kernel and two user processes"></p><h2 id="Kernel-organization"><a href="#Kernel-organization" class="headerlink" title="Kernel organization"></a>Kernel organization</h2><table><thead><tr><th>Organization</th><th>Description</th><th>Upside</th><th>Downside</th></tr></thead><tbody><tr><td>monolithic kernel</td><td>the entire OS resides in the kernel with full privilege</td><td>convenient, <br>easier for different parts of the OS to cooperate</td><td>complex interfaces, <br>easy to make a mistake, <br>a mistake is fatal</td></tr><tr><td>microkernel</td><td>minimize the code that runs in supervisor mode, <br>execute the bulk of the OS in user mode</td><td>reduce the risk of mistakes in the kernel</td><td></td></tr></tbody></table><p><img src="/Blog/.io//Xv6-operating-system-organization/microkernel.png" alt="A microkernel with a file-system server"></p><p>(NOTE&gt; OS services running as processes are called servers)</p><h2 id="Xv6-organization"><a href="#Xv6-organization" class="headerlink" title="Xv6 organization"></a>Xv6 organization</h2><p>Xv6 kernel source files:</p><table><thead><tr><th>File</th><th>Description</th></tr></thead><tbody><tr><td>bio.c</td><td>Disk block cache for the file system.</td></tr><tr><td>console.c</td><td>Connect to the user keyboard and screen.</td></tr><tr><td>entry.S</td><td>Very first boot instructions.</td></tr><tr><td>exec.c</td><td>exec() system call.</td></tr><tr><td>file.c</td><td>File descriptor support.</td></tr><tr><td>fs.c</td><td>File system.</td></tr><tr><td>kalloc.c</td><td>Physical page allocator.</td></tr><tr><td>kernelvec.S</td><td>Handle traps from kernel, and timer interrupts.</td></tr><tr><td>log.c</td><td>File system logging and crash recovery.</td></tr><tr><td>main.c</td><td>Control initialization of other modules during boot.</td></tr><tr><td>pipe.c</td><td>Pipes.</td></tr><tr><td>plic.c</td><td>RISC-V interrupt controller.</td></tr><tr><td>printf.c</td><td>Formatted output to the console.</td></tr><tr><td>proc.c</td><td>Processes and scheduling.</td></tr><tr><td>sleeplock.c</td><td>Locks that yield the CPU.</td></tr><tr><td>spinlock.c</td><td>Locks that don’t yield the CPU.</td></tr><tr><td>start.c</td><td>Early machine-mode boot code.</td></tr><tr><td>string.c</td><td>C string and byte-array library.</td></tr><tr><td>swtch.S</td><td>Thread switching.</td></tr><tr><td>syscall.c</td><td>Dispatch system calls to handling function.</td></tr><tr><td>sysfile.c</td><td>File-related system calls.</td></tr><tr><td>sysproc.c</td><td>Process-related system calls.</td></tr><tr><td>trampoline.S</td><td>Assembly code to switch between user and kernel.</td></tr><tr><td>trap.c C</td><td>code to handle and return from traps and interrupts.</td></tr><tr><td>uart.c</td><td>Serial-port console device driver.</td></tr><tr><td>virtio_disk.c</td><td>Disk device driver.</td></tr><tr><td>vm.c</td><td>Manage page tables and address spaces.</td></tr></tbody></table><p>(From: <code>pbpaste | awk &#39;&#123; printf(&quot;| %s |&quot;, $1); for (i=2; i&lt;=NF; i++) printf(&quot; %s&quot;, $i); printf(&quot; |\n&quot;); &#125;&#39; | pbcopy</code>)</p><p>The inter-module interfaces are defined in <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/defs.h">kernel&#x2F;defs.h</a>.</p><h2 id="Process-overview"><a href="#Process-overview" class="headerlink" title="Process overview"></a>Process overview</h2><h3 id="Process"><a href="#Process" class="headerlink" title="Process"></a>Process</h3><p>The unit of isolation: a <em>process</em>: an illusion to a program that it has its own private machine (private memory, CPU, file descriptors, etc.). Process is defined as <code>struct proc</code> (<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/proc.h#L86">kernel&#x2F;proc.h:86</a>).</p><ul><li><code>p-&gt;state</code>: whether the process is allocated, ready to run, running, waiting for I&#x2F;O, or exiting:</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">procstate</span> &#123;</span> UNUSED, USED, SLEEPING, RUNNABLE, RUNNING, ZOMBIE &#125;;</span><br></pre></td></tr></table></figure><ul><li><code>p-&gt;pagetable</code>: holds the process’s page table.</li></ul><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><p><em>Thread</em> (of execution): executes the process’s instructions.</p><p>A thread can be suspended and later resumed.</p><p>Threads can “block” in the kernel to wait for I&#x2F;O, and resume where it left off when the I&#x2F;O has finished.</p><h3 id="Virtual-address"><a href="#Virtual-address" class="headerlink" title="Virtual address"></a>Virtual address</h3><p>Virtual address: Isolation of memory:  <code>virtual address -- page tables --&gt; physical address</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MAXVA</span><br><span class="line">↑    trampoline</span><br><span class="line">|    trapframe</span><br><span class="line">|    Heap</span><br><span class="line">|    Stack (user stack)</span><br><span class="line">|    Global Variables (text and data)</span><br><span class="line">|    Instructions</span><br><span class="line">0</span><br></pre></td></tr></table></figure><ul><li>VA is starting at zero</li><li>MAXVA (the maximum virtual address) defined in <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/riscv.h#L348"> kernel&#x2F;riscv.h:348</a>: Xv6 uses 38 bits to look up virtual addresses in page tables: $\textrm{MAXVA}&#x3D;2^{38}-1&#x3D;\textrm{0x3fffffffff}$</li><li>Each process has two stacks: user stack &amp; kernel stack (<code>p-&gt;kstack</code>, for a system call or interrupt, separate and protected from user code).</li></ul><h3 id="System-call"><a href="#System-call" class="headerlink" title="System call"></a>System call</h3><p><code>ecall</code>: a RISC-V instruction to make a system call:</p><ol><li>raises hardware privilege level</li><li>change PC to a kernel-defined entry point, switches to a kernel stack</li><li>executes the kernel instructions</li><li>(system call completes) switches back to the user stack</li><li>returns to user space by calling the <code>sret</code> instruction (lowers the hardware privilege level)</li><li>resumes executing user instructions just after the system call instruction</li></ol><h2 id="Starting-xv6-and-the-first-process"><a href="#Starting-xv6-and-the-first-process" class="headerlink" title="Starting xv6 and the first process"></a>Starting xv6 and the first process</h2><ol><li>RISC-V computer powers on, self initializes</li><li>runs a boot loader (stored in ROM): loads the xv6 kernel into memory at physical address 0x80000000 (range 0x0:0x80000000 contains I&#x2F;O devices)</li><li>(in machine mode) executes xv6 starting at <code>_entry</code> (<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/entry.S#L6">kernel&#x2F;entry.S:6</a>), sets up a stack (<code>stack0</code>) for C code (<code>sp = stack0 + (hartid * 4096)</code>)</li><li><code>_entry</code> calls into C code: function  <code>start</code> (<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/start.c#L11">kernel&#x2F;start.c:11</a>)</li><li><code>start</code>  performs configuration(page-table, interrupts…)</li><li>switches to supervisor mode, PC change to <code>main</code> (<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/main.c#L11">kernel&#x2F;main.c:11</a>)</li><li><code>main</code> initializes several devices and subsystems</li><li>creates the first process by calling userinit (<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/proc.c#L212">kernel&#x2F;proc.c:212</a>)</li><li>run <code>initcode.S</code> (<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/initcode.S#L1">user&#x2F;initcode.S:1</a>), do <code>exec(&quot;/init&quot;)</code></li><li><code>init</code>  (<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/init.c#L15">user&#x2F;init.c:15</a>) creates a console device file, opens it as file descriptors 0, 1, and 2</li><li>starts a shell on the console</li><li>The system is up.</li></ol><hr><p>EOF</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// By CDFMLR 2021-02-27</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;See you.\n&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Queue for Moving Window</title>
      <link href="/Blog/2022/07/16/Algorithms/MovingWindow/"/>
      <url>/Blog/2022/07/16/Algorithms/MovingWindow/</url>
      
        <content type="html"><![CDATA[<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Moving window is the type of questions that has a specified size $k$ of window skim across an array, performing filtering on the numbers such as averaging or finding local maximum value. It is straightforward to update the maximal value when a new number is added to the array iteratively whereas removing a value at the same time complex the problem.</p><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p><p>Example:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Input: nums = [1,3,-1,-3,5,3,6,7], k = 3</span><br><span class="line">Output: [3,3,5,5,6,7]</span><br><span class="line">Explanation:</span><br><span class="line">Window position                Max</span><br><span class="line">---------------               -----</span><br><span class="line">[1  3  -1] -3  5  3  6  7       3</span><br><span class="line"> 1 [3  -1  -3] 5  3  6  7       3</span><br><span class="line"> 1  3 [-1  -3  5] 3  6  7       5</span><br><span class="line"> 1  3  -1 [-3  5  3] 6  7       5</span><br><span class="line"> 1  3  -1  -3 [5  3  6] 7       6</span><br><span class="line"> 1  3  -1  -3  5 [3  6  7]      7</span><br></pre></td></tr></table></figure><h2 id="Thinking"><a href="#Thinking" class="headerlink" title="Thinking"></a>Thinking</h2><p>The first idea of solving this problem is Brute Force which has time complexity as $O(nk)$ and $O(1)$. In this case repetitive comparing is performed unless the hopping size is smaller than 3 (Think about that at step $i$, the comparison between $nums[i+1]$ and $nums[]$ will be conducted again at iteration $i+1$).</p><p>Two data structures are good solutions to this problem as they allow easy maximal value finding when element-wise updating happens: priority queue (heap) and monotonic queue. Python provides packages for them both(heapq &amp; collections.deque) for use but it is good to understand the working mechanisms. This note will go through both structures in a bottom-up way.</p><h1 id="Priority-queue"><a href="#Priority-queue" class="headerlink" title="Priority queue"></a>Priority queue</h1><p>Priority queue acts like a queue in that you dequeue an item by removing it from the front. However, in a priority queue the logical order of items inside a queue is determined by their priority. Thus when a new item joins the priority queue, it may move its way up until the front, which is a useful property for many applications such as sorting problems.</p><h2 id="Complete-Binary-Tree"><a href="#Complete-Binary-Tree" class="headerlink" title="Complete Binary Tree"></a>Complete Binary Tree</h2><p>Although a priority queue can be implemented using $list$ with sorting functions, inserting into a list is $O(n)$ and sorting is $O(nlogn)$. Meanwhile, a binary heap allows both enqueue and dequeue items in $O(logn)$ hence is usually more popular.</p><p>It is worth noting that a binary heap diagram looks like a tree but the actual structure is an array(usually a list in Python). This is because the index of its elements follow strictly the structure of a $complete binary tree$, where all levels except the deepest are fully filled and the nodes of the lowest are filled from left to right. An extra property for heap is either the key stored in each node is greater&#x2F;equal than the keys in the node’s children (Max heap) or small&#x2F;equal(Min heap).</p><p>The advantage of a complete binary tree is that it ensures a index relation between a parent node and all its children nodes: for any parent node $i$, it’s left node and right node (if exists) are at the index of $2i+1$ and $2i+2$. Reversely, for any node, its parent node’s index is $(i-1)&#x2F;&#x2F;2$(if i&#x3D;0 is the root node). This property make it very convenient for traversing tree nodes following the relations.</p><p>Now the issue is to maintain the property in the queue and dequeue operations. After inserting a new element, for example, it compare the value of the new element $nums[i]$ with its parent node nums[(i-1)&#x2F;&#x2F;2] and if the relation violates the property, they switch position. The comparison and switching keep happening until the property is restored:</p><p><img src="http://www.openbookproject.net/books/pythonds/_images/percUp.png" alt="Adding element"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># restore the property after a new element is inserted at the ith --- max heap</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perc_up</span>(<span class="params">self, i</span>):</span><br><span class="line">  <span class="keyword">while</span> (i-<span class="number">1</span>) // <span class="number">2</span> &gt; <span class="number">0</span>: <span class="comment"># Assuming the tree and the array share the index and root index i=0</span></span><br><span class="line">    <span class="keyword">if</span> self.heap_list[i] &gt; self.heap_list[(i-<span class="number">1</span>)//<span class="number">2</span>]:</span><br><span class="line">       <span class="comment"># The new element larger than its parent</span></span><br><span class="line">       tmp = self.heap_list[(i-<span class="number">1</span>)//<span class="number">2</span>]</span><br><span class="line">       self.heap_list[(i-<span class="number">1</span>)//<span class="number">2</span>] = self.heap_list[i]</span><br><span class="line">       self.heap_list[i] = tmp</span><br><span class="line">       i = (i-<span class="number">1</span>) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">insert</span>(<span class="params">self,k</span>):</span><br><span class="line">  self.heap_list.append(k)</span><br><span class="line">  self.current_size = self.current_size+<span class="number">1</span></span><br><span class="line">  self.perc_up(self.current_size)</span><br></pre></td></tr></table></figure><p>Removing the head(maximum) of the heap follows the steps:</p><ul><li>Remove the root node</li><li>pop out the end of the queue and replace as the root</li><li>compare the value of the new root with its children and switch its position with the child node with greater value.</li><li>continue the previous step until the order is restored.</li></ul><p><img src="http://www.openbookproject.net/books/pythonds/_images/percDown.png" alt="dequeue"></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># restore the property after removing the head</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">perc_down</span>(<span class="params">self, i</span>):</span><br><span class="line">  <span class="comment">#The i is not necessarily the root nodes, root node index is 0</span></span><br><span class="line">  <span class="keyword">while</span> <span class="number">2</span>*i+<span class="number">1</span> &lt;= self.current_size:</span><br><span class="line">    mc = self.max_child(i)</span><br><span class="line">    <span class="keyword">if</span> self.heap_list[i.] &lt; self.heap_list[mc]:</span><br><span class="line">      tmp = self.heap_list[mc]</span><br><span class="line">      self.heap_list[mc] = self.heap_list[i]</span><br><span class="line">      self.heap_list[i] = tmp</span><br><span class="line">    i = mc</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max_child</span>(<span class="params">self, i</span>):</span><br><span class="line">  <span class="keyword">if</span> i*<span class="number">2</span>+<span class="number">2</span>&gt; self.current_size:</span><br><span class="line">    <span class="keyword">return</span> i*<span class="number">2</span>+<span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> i*<span class="number">2</span>+<span class="number">1</span> <span class="keyword">if</span> self.heap_list[i*<span class="number">2</span>+<span class="number">1</span>]&gt;self.heap_list[i*<span class="number">2</span>+<span class="number">2</span>] <span class="keyword">else</span> i*<span class="number">2</span>+<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">del_head</span>(<span class="params">self</span>):</span><br><span class="line">  ret = self.heap_list[<span class="number">0</span>]</span><br><span class="line">  self.heap_list[<span class="number">0</span>] = self.heap_list[-<span class="number">1</span>]</span><br><span class="line">  self.current_size -=<span class="number">1</span></span><br><span class="line">  self.heap_list.pop()</span><br><span class="line">  self.perc_down(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure><p>A powerful property of heap is for any element in the array, it only takes $logn$ times (the level numbers) of comparing and switching to ensure it is smaller&#x2F;greater than its parent node. Applied to every nodes, the time complexity of heap sorting is therefore $nlogn$ to an array.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>Python provides $heapq$, which does the order restoring as above for us. We only need to take care of the FIFO tasks. As the default heapq in Python is minimum heap, we can create a new array with -nums[i] elements instead. The implementation is as below:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        n = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="comment"># 注意 Python 默认的优先队列是小根堆</span></span><br><span class="line">        q = [(-nums[i], i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k)] <span class="comment"># value and index</span></span><br><span class="line">        heapq.heapify(q) <span class="comment">#Transform a list into a heap, in-place, in linear time</span></span><br><span class="line"></span><br><span class="line">        ans = [-q[<span class="number">0</span>][<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k, n):</span><br><span class="line">            heapq.heappush(q, (-nums[i], i)) <span class="comment"># Push while maintaining the heap invariant</span></span><br><span class="line">            <span class="keyword">while</span> q[<span class="number">0</span>][<span class="number">1</span>] &lt;= i - k:</span><br><span class="line">                heapq.heappop(q) <span class="comment"># pop and return the smallest item from the heap</span></span><br><span class="line">            ans.append(-q[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>The time complexity of solution is $O((n-k)*logn)$ because the worst case is k&gt;n and pushing and poping an element are both $O(logn)$ (Actually from maintaining the heap invariant). Space complexity is $O(n)$.</p><h1 id="Monotonic-dequeue"><a href="#Monotonic-dequeue" class="headerlink" title="Monotonic dequeue"></a>Monotonic dequeue</h1><p>Removing the head of a list is $O(n)$ because the index of all elements need to shift a step backward. Dequeue is therefore implemented for convenience operations on both ends(operating on the middle is still $O(n)$).</p><p>Now re-think the problem: if we keeps a monotonically decreasing stack at iteration $i$, and at the step $i+1$ we compare the new element with the last element in the stack. If the new element is larger, the last element in the stack is no longer useful: if it cannot win the current iteration, it definetely will not win the next. So we can safely pop it out and replace it with the new element. Continue until the new element can be pushed as the tail of the stack then check if the head element is still in the window from the index. If it is still in, it is return as the answer of this round. If not, pop the head out and return the new head. To speed up the head popping, dequeue is used instead of stack.</p><p>Example:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3</span><br><span class="line">输出: [3,3,5,5,6,7]</span><br><span class="line"></span><br><span class="line">解释过程中队列中都是具体的值，方便理解，具体见代码。</span><br><span class="line">初始状态：L=R=0,队列:&#123;&#125;</span><br><span class="line">i=0,nums[0]=1。队列为空,直接加入。队列：&#123;1&#125;</span><br><span class="line">i=1,nums[1]=3。队尾值为1，3&gt;1，弹出队尾值，加入3。队列：&#123;3&#125;</span><br><span class="line">i=2,nums[2]=-1。队尾值为3，-1&lt;3，直接加入。队列：&#123;3,-1&#125;。此时窗口已经形成，L=0,R=2，result=[3]</span><br><span class="line">i=3,nums[3]=-3。队尾值为-1，-3&lt;-1，直接加入。队列：&#123;3,-1,-3&#125;。队首3对应的下标为1，L=1,R=3，有效。result=[3,3]</span><br><span class="line">i=4,nums[4]=5。队尾值为-3，5&gt;-3，依次弹出后加入。队列：&#123;5&#125;。此时L=2,R=4，有效。result=[3,3,5]</span><br><span class="line">i=5,nums[5]=3。队尾值为5，3&lt;5，直接加入。队列：&#123;5,3&#125;。此时L=3,R=5，有效。result=[3,3,5,5]</span><br><span class="line">i=6,nums[6]=6。队尾值为3，6&gt;3，依次弹出后加入。队列：&#123;6&#125;。此时L=4,R=6，有效。result=[3,3,5,5,6]</span><br><span class="line">i=7,nums[7]=7。队尾值为6，7&gt;6，弹出队尾值后加入。队列：&#123;7&#125;。此时L=5,R=7，有效。result=[3,3,5,5,6,7]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>And the code:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单调双端队列 O(n)，O（k）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">maxSlidingWindow</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(nums) &lt; <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> nums</span><br><span class="line">        queue = collections.deque()</span><br><span class="line">        res = [<span class="number">0</span>] * (<span class="built_in">len</span>(nums)-k+<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="comment">#保证从大到小 如果前面数小则需要依次弹出，直至满足要求</span></span><br><span class="line">            <span class="keyword">while</span> queue <span class="keyword">and</span> nums[queue[-<span class="number">1</span>]] &lt;= nums[i]:</span><br><span class="line">                queue.pop()</span><br><span class="line">            queue.append(i)</span><br><span class="line">            <span class="comment">#判断队首值是否有效</span></span><br><span class="line">            <span class="keyword">if</span> queue[<span class="number">0</span>] &lt;= i - k:</span><br><span class="line">                queue.popleft()</span><br><span class="line">            <span class="comment">#当窗口长度为k时 保存当前窗口中最大值</span></span><br><span class="line">            <span class="keyword">if</span> i + <span class="number">1</span> &gt;= k:</span><br><span class="line">                res[i+<span class="number">1</span>-k] = nums[queue[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure><p>The time complexity is $O(n)$ and the space complexity is $O(k)$.</p>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Monotonic Stack</title>
      <link href="/Blog/2022/07/15/Algorithms/MonotonicStack/"/>
      <url>/Blog/2022/07/15/Algorithms/MonotonicStack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考: <a href="https://leetcode.cn/problems/trapping-rain-water/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-w-8/">Trapping Rain Water</a><br><a href="https://leetcode.cn/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/">Daily Temperatures</a><br><a href="https://leetcode.cn/problems/next-greater-element-i/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-w/">Next Greater Element I</a></p></blockquote><h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Monotonic Stack is a stack where elements are in monotonically order. It is mostly used for solving the “Next Greater Element” problems such as finding the next higher temperature in the “Daily Temperatures”. Sometimes the index of the elements are stored instead of the elements themselves for convenience. In the “Next Greater Element Problem”, for instance, we aim to identify the event of greater element occurring and to perform certain tasks when it happens. In “Daily Temperatures”, the task is to find the date of the next higher temperature while in the “Trapping Rain Water”, the task becomes computing the volume of water trapped in the convex. This article is to summarize the usage of monotonic stack in solving such problems.</p><h1 id="Next-Greater-Element-Leedcode-496"><a href="#Next-Greater-Element-Leedcode-496" class="headerlink" title="Next Greater Element - Leedcode 496"></a>Next Greater Element - Leedcode 496</h1><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><p>The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.</p><p>You are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.</p><p>For each 0 &lt;&#x3D; i &lt; nums1.length, find the index j such that nums1[i] &#x3D;&#x3D; nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.</p><p>Return an array ans of length nums1.length such that ans[i] is the next greater element as described above.</p><p>Example 1:</p><p>Input: nums1 &#x3D; [4,1,2], nums2 &#x3D; [1,3,4,2]<br>Output: [-1,3,-1]<br>Explanation: The next greater element for each value of nums1 is as follows:</p><ul><li>4 is underlined in nums2 &#x3D; [1,3,4,2]. There is no next greater element, so the answer is -1.</li><li>1 is underlined in nums2 &#x3D; [1,3,4,2]. The next greater element is 3.</li><li>2 is underlined in nums2 &#x3D; [1,3,4,2]. There is no next greater element, so the answer is -1.</li></ul><h2 id="solution"><a href="#solution" class="headerlink" title="solution"></a>solution</h2><p>Other than brute force method, this is a typical problem for monotonic stack. What we want to do is assign the value of the next greater element to the current index. As $nums1$ is not strictly following the order of $nums2$, it is better to create a hashtable while iterating $nums2$ for later look-up. The steps to finding such greater numbers of $nums2$ are:</p><ul><li>create an empty stack and list for answer: $ans &#x3D; [-1]*len(nums2)$</li><li>iterate elements in $nums2$, compare it with the element at the top of stack if there is any. If if is smaller or equal(depending on the requirement of the problem) to the peek, push it into the stack. otherwise, keep popping the peek elements out until the new peek of the stack is bigger or the stack is empty. I store the index of the elements instead of the elements themselves in the stack for convenient assignment. Whenever a element: $nums[j]$ got popped out because of another element $nums2[i]$, assign the value of $nums[i]$ to the answer list: $ans[j] &#x3D; nums2[i]$.</li></ul><p>In such way, the stack maintains a way of decreasing elements and the code is as below:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">nextGreaterElement</span>(<span class="params">self, nums1: <span class="type">List</span>[<span class="built_in">int</span>], nums2: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        hashtable = <span class="built_in">dict</span>()</span><br><span class="line">        ans = [-<span class="number">1</span>]*<span class="built_in">len</span>(nums1)</span><br><span class="line">        look_up_table = [-<span class="number">1</span>]*<span class="built_in">len</span>(nums2)</span><br><span class="line">        <span class="comment"># obatin the look up table</span></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums2):</span><br><span class="line">            hashtable[num] = i</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> num &gt; nums2[stack[-<span class="number">1</span>]]:</span><br><span class="line">                prev_index = stack.pop()</span><br><span class="line">                look_up_table[prev_index] = nums2[i]</span><br><span class="line">            stack.append(i)</span><br><span class="line">        <span class="comment"># get the results</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums1)):</span><br><span class="line">            ans[index] = look_up_table[hashtable[nums1[index]]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Leedcode-503 is the same question but with a circular array, which is while looking for greater elements, the current element does not stop at the end of the array but continue traversing from the head until itself. Simply concatenating the array with itself and do the same thing on the new array will address the problem: $Nums &#x3D; nums+ nums$. LeedCode-739 “Daily Temperatures” is the similar problem only now we want to know how many days we need to wait for a higher daily temperature. This can be simply solved with subtraction of the index. The code can be found in Leedcode therefore will not be posted here.  </p><h1 id="Trapping-Rain-Water-Leedcode-42"><a href="#Trapping-Rain-Water-Leedcode-42" class="headerlink" title="Trapping Rain Water - Leedcode 42"></a>Trapping Rain Water - Leedcode 42</h1><h2 id="Question-1"><a href="#Question-1" class="headerlink" title="Question"></a>Question</h2><p>Given $n$ non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</p><p>Example:</p><p><img src="https://assets.leetcode.com/uploads/2018/10/22/rainwatertrap.png" alt="Trapping Water"></p><p>Input: height &#x3D; [0,1,0,2,1,0,1,3,2,1,2,1]<br>Output: 6<br>Explanation: The above elevation map (black section) is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped.</p><h2 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h2><p>The difficulty is to recognize that whenever height value at index of $i$ is greater than $i+1$, we want to know the convex column formed by $i-2$ and $i$. This is a typical “Next Greater Element”: perform a operation whenever a greater element occur than the element at the top of the stack.</p><p>A starting method to solve the problem is  find the highest left wall and right wall for every slots then compute the use the lower wall of them to subtract the slot to find the water unit specifically saved by this slow. If the lower of them is lower than the current unit, no water is saved by this slow:<br><img src="https://pic.leetcode-cn.com/542754f4431d93141920185252aee31664a96dd17285b92dfe390e9e977bebb1-image.png" alt="Scheme of Walls"></p><p>To find the walls, the first method is of course Brute Force, whereas the time complexity is $O(n^2)$ and space complexity is $O(1)$ as we only need to the current highest walls. To simplify, dynamic programming is used where the highest walls from previous iteration are compared with the left and right wall of the current slot and get the updated highest walls. In such way, there is no need to traverse the whole array again for every slots. This will decrease the time complexity to $O(n)$. The space complexity is now $o(n)$ as the highest walls of every slot need to be kept. The code of this method will not be presented in this article as it does not concern with monotonic stack.</p><p>The idea is the same as in the “Next Greater Element”. Whenever a higher height appears, it pops out the top element and compare the new top element with this higher value. This resembles the brackets in the calculator problem.<br>Scheme:<br><img src="https://pic.leetcode-cn.com/37fccd915f959c2046ffc1ab2b0a1e4d921869337d8d5d4aa218886ab0bf7c8a-image.png" alt="Brackets &amp; Rain">.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python code</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">trap</span>(<span class="params">self, height: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        stack = <span class="built_in">list</span>()</span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        N = <span class="built_in">len</span>(height)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,N):</span><br><span class="line">            h = height[i]</span><br><span class="line">            <span class="keyword">while</span> stack <span class="keyword">and</span> h&gt; height[stack[-<span class="number">1</span>]]:</span><br><span class="line">                low_index = stack.pop()</span><br><span class="line">                <span class="keyword">if</span> stack:</span><br><span class="line">                    height_diff = <span class="built_in">min</span>(h, height[stack[-<span class="number">1</span>]])-height[low_index]</span><br><span class="line">                    <span class="built_in">sum</span> += height_diff* (i-stack[-<span class="number">1</span>]-<span class="number">1</span>) <span class="comment"># The index difference is the length</span></span><br><span class="line">            stack.append(i)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Validate Stack Sequences</title>
      <link href="/Blog/2022/07/11/Algorithms/ValidateStack/"/>
      <url>/Blog/2022/07/11/Algorithms/ValidateStack/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考: <a href="https://leetcode.cn/problems/validate-stack-sequences/solution/yan-zheng-zhan-xu-lie-by-leetcode/">Validate Stack Sequences</a></p></blockquote><h1 id="Question-946"><a href="#Question-946" class="headerlink" title="Question-946"></a>Question-946</h1><p>Given two integer arrays $pushed$ and $popped$ each with distinct values, return $true$ if this could have been the result of a sequence of push and pop operations on an initially empty stack, or $false$ otherwise.</p><p>Example 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]</span><br><span class="line">Output: true</span><br><span class="line">Explanation: We might do the following sequence:</span><br><span class="line">push(1), push(2), push(3), push(4),</span><br><span class="line">pop() -&gt; 4,</span><br><span class="line">push(5),</span><br><span class="line">pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]</span><br><span class="line">Output: false</span><br><span class="line">Explanation: 1 cannot be popped before 2.</span><br></pre></td></tr></table></figure><p>Constraints:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* 1 &lt;= pushed.length &lt;= 1000</span><br><span class="line">* 0 &lt;= pushed[i] &lt;= 1000</span><br><span class="line">* All the elements of pushed are unique.</span><br><span class="line">* popped.length == pushed.length</span><br><span class="line">* popped is a permutation of pushed</span><br></pre></td></tr></table></figure><h1 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h1><p>The problem uses Simulation method: create a empty stack and simulate the constructing process of $popped$ from $pushed$. Assuming successful construction, it is easy to notice that the number of pop operation should be the length of $popped$ no matter what the order is. The restrictions are, therefore, essential in the construction: the maximum number of \b{pop}; the numbers in $pushed$ can run out only once; Hence, at $i&#x3D;0,1,2…N-1$ iteration, the $i_{th}$ number of the $pushed$ is pushed into the new stack. Then do the stack popping on while loop with the conditions:</p><ul><li>The new stack is not empty</li><li>The number of pop operation: $j$ hasn’t reached the length of $popped$</li><li>The number at the top of the new stack (the one that is just popped) equals to the $j_{th}$ number of $popped$. It has to be exactly the $j_{th}$ because the order of popped elements won’t match otherwise.</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python code</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">validateStackSequences</span>(<span class="params">pushed: <span class="type">List</span>[<span class="built_in">int</span>], popped: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    new_stack = <span class="built_in">list</span>()</span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    N = <span class="built_in">len</span>(pushed)</span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> pushed:</span><br><span class="line">        new_stack.append(num)</span><br><span class="line">        <span class="keyword">while</span> new_stack <span class="keyword">and</span> j&lt; N <span class="keyword">and</span> new_stack[-<span class="number">1</span>] == popped[j]:</span><br><span class="line">            new_stack.pop()</span><br><span class="line">            j+=<span class="number">1</span>      </span><br><span class="line">    <span class="keyword">return</span> j == N</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h1><p>This question tests the usage of stack structure and familiarize me with Simulation method.  </p>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Calculator</title>
      <link href="/Blog/2022/07/10/Algorithms/Calculator/"/>
      <url>/Blog/2022/07/10/Algorithms/Calculator/</url>
      
        <content type="html"><![CDATA[<blockquote><small><i>设计一个计算器最头疼的就是中序后缀表达式中的括号，比如3+4x5 与 (3+4)x5 的计算顺序造成结果不一样。一个经典的解决办法就是将其转化成后缀表达式，也称逆波兰式。本文章是因为经常碰到设计计算器或者类似的题目，做一个总结来捋一捋。</i></small></blockquote><h2 id="Reverse-Polish-notation"><a href="#Reverse-Polish-notation" class="headerlink" title="Reverse Polish notation"></a>Reverse Polish notation</h2><p>The idea of Reverse Polish notation is to convert the infix notation into a format of:<br>$$ (Num_{left})\ (Num_{right})\ Ops $$<br>and maintain that for the whole expression. Where there are consecutive operands, the operand with higher priority goes first. For instance:<br>$$ 3-4\times 5 &#x3D;&gt; 3\quad4\quad5\times- $$<br>and conversely:<br>$$ (3-4)\times 5 &#x3D;&gt; 3\quad4 - 5\times\quad$$<br>Later in the calculating, whenever the program read a operand from the postfix expression, it pops out the previous two numbers, calculate with the operand and push the result back to the stack. Eventually, the last number left in the stack will be the result of the equation.</p><h2 id="Infix-to-Postfix"><a href="#Infix-to-Postfix" class="headerlink" title="Infix to Postfix"></a>Infix to Postfix</h2><p>So we know how Reverse Polish notation can be useful. What’s next is how to generate it from infix expression. Let’s start from the easy part where there aren’t any brackets. In such case, the converter only cares about the priority:</p><ul><li>‘*’ and ‘&#x2F;‘ have higher priority than ‘+’ and ‘-‘</li><li>When the priorities are equal, operand on the left has higher priority</li></ul><p>Hence, create stacks $\color{red}{ops}$ to store the operands and $\color{green}{out}$, read chars from the infix expression:</p><ul><li>If a char is a number, push it into $\color{green}{out}$</li><li>If a char is a operand, compare it with the operand at the top of the $\color{red}{ops}$:<ul><li>If it has higher priority, push it into $\color{red}{ops}$</li><li>If it has lower or equal priority, pop a operand from $\color{red}{ops}$ and push it into $\color{green}{out}$ until finding the next ‘higher’ operand. Then push the new char into<br>$$\color{red}{ops}$.</li></ul></li><li>When the iteration on Infix expression finish, pop what’s left in $\color{red}{ops}$ and push into $\color{green}{out}$.</li></ul><p>Now brings in the brackets, what it does is simply making a mark for ‘coming back’ that functions as the ‘higher’ operand. That is, when the char is ‘)’, the $\color{red}{ops}$ keeps popping elements and pushing them into $\color{green}{out}$ until it pops out the nearest ‘(‘. To avoid ‘(‘ from disrupting other operands’ popping, the priority of ‘(‘ is set to be the lowest. Note: No need to set ‘)’ priority because it will never be pushed into the stack.</p><p>Example:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python code</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">infixToPost</span>(<span class="params">s</span>):</span><br><span class="line">    level = &#123;&#125;</span><br><span class="line">    level[<span class="string">&#x27;*&#x27;</span>] = <span class="number">3</span></span><br><span class="line">    level[<span class="string">&#x27;/&#x27;</span>] = <span class="number">3</span></span><br><span class="line">    level[<span class="string">&#x27;+&#x27;</span>] = <span class="number">2</span></span><br><span class="line">    level[<span class="string">&#x27;-&#x27;</span>] = <span class="number">2</span></span><br><span class="line">    level[<span class="string">&#x27;(&#x27;</span>] = <span class="number">1</span></span><br><span class="line">    nums = <span class="string">&#x27;0123456789&#x27;</span></span><br><span class="line">    ops = <span class="string">&#x27;()+-*/&#x27;</span></span><br><span class="line">    out = <span class="built_in">list</span>()</span><br><span class="line">    stack = <span class="built_in">list</span>()</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> nums:</span><br><span class="line">            out.append(c)</span><br><span class="line">        <span class="keyword">elif</span> c <span class="keyword">in</span> ops:</span><br><span class="line">            <span class="keyword">if</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                stack.append(c)</span><br><span class="line">            <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">                <span class="keyword">while</span> (sign := stack.pop()) != <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">                    out.append(sign)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">while</span> stack <span class="keyword">and</span> level[stack[-<span class="number">1</span>]] &gt;= level[c]:</span><br><span class="line">                    out.append(stack.pop())</span><br><span class="line">                stack.append(c)</span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        out.append(stack.pop())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.join(out)</span><br></pre></td></tr></table></figure><h2 id="Calculation"><a href="#Calculation" class="headerlink" title="Calculation"></a>Calculation</h2><p>The idea has been explained in the previous section:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># calculation</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">postfix_eval</span>(<span class="params">postfix_expr</span>):</span><br><span class="line">    operand_stack =Stack()</span><br><span class="line">    postfix_list = postfix_expr.split()</span><br><span class="line">    <span class="keyword">for</span> token <span class="keyword">in</span> postfix_list:</span><br><span class="line">        <span class="keyword">if</span> token.isnumeric():</span><br><span class="line">            operand_stack.push(<span class="built_in">int</span>(token))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            top_operand2 = operand_stack.pop()</span><br><span class="line">            top_operand1 = operand_stack.pop()</span><br><span class="line">            result = do_math(token,top_operand1,top_operand2)</span><br><span class="line">            operand_stack.push(result)</span><br><span class="line">    <span class="keyword">return</span> operand_stack.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace the string to operator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">do_math</span>(<span class="params">op, op1, op2</span>):</span><br><span class="line">    <span class="keyword">if</span> op == <span class="string">&quot;+&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1+op2</span><br><span class="line">    <span class="keyword">elif</span> op==<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1-op2</span><br><span class="line">    <span class="keyword">elif</span> op==<span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1*op2</span><br><span class="line">    <span class="keyword">elif</span> op==<span class="string">&#x27;/&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> op1/op2</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Practice-Leedcode-224"><a href="#Practice-Leedcode-224" class="headerlink" title="Practice: Leedcode 224"></a>Practice: Leedcode 224</h2><h3 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h3><p>Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation. Example 1: s &#x3D; “1 + 1”, output: 2; Example 2: s &#x3D; “2 -1 + 2”, output: 3; Example 3: s &#x3D; “(1+(4+5+2)-3)+(6+8)” , output: 23.</p><h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><p>As there are only addition and subtraction, no need to consider the priority but only the brackets. The idea is to keep track of the result from the left equation, the sign (+&#x2F;-) and the number as the right equation (similar to postfix). When the program read ‘(‘, it stack the res and sign, then reset them as 0s to tackle the equation inside the bracket as a new equation:</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">calculate</span>(<span class="params">s</span>):</span><br><span class="line">    res, num, sign = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    stack = []</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> c.isdigit():</span><br><span class="line">            num = <span class="number">10</span> * num +<span class="built_in">int</span>(c)</span><br><span class="line">        <span class="keyword">elif</span> c ==<span class="string">&#x27;+&#x27;</span> <span class="keyword">or</span> c ==<span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">            res = res + sign*num</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            sign = <span class="number">1</span> <span class="keyword">if</span> c ==<span class="string">&#x27;+&#x27;</span> <span class="keyword">else</span> -<span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;(&#x27;</span>:</span><br><span class="line">            stack.append(res)</span><br><span class="line">            stack.append(sign)</span><br><span class="line">            res = <span class="number">0</span></span><br><span class="line">            sign = <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> c == <span class="string">&#x27;)&#x27;</span>:</span><br><span class="line">            res += sign*num</span><br><span class="line">            num = <span class="number">0</span></span><br><span class="line">            res *= stack.pop()</span><br><span class="line">            res += stack.pop()</span><br><span class="line">    res += sign * num</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>简而言之，计算器的关键是要用栈来构建后缀表达式。在后缀表达式中，先使用的计算符会放在前面，保证计算过程中会被先执行。而构建后缀的方法则是创建一个操作符栈，每当新的符号优先级低于操作符栈顶端的符号，则会弹出栈里面的优先级别大于或等于新符号的所有操作符，并放进输出。与此同时，类似的如果新的操作符是右括号，则会弹出并压入输出栈所有在左括号上方的所有符号，依次压入输出栈。迭代完后，把操作符栈剩下的符号以此弹出压入输出。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>Wikipedia. Reverse Polish notation. <a href="https://en.wikipedia.org/wiki/Reverse_Polish_notation#Explanation">https://en.wikipedia.org/wiki/Reverse_Polish_notation#Explanation</a></li><li>Leedcode. Basic calculator. <a href="https://leetcode.cn/problems/basic-calculator/">https://leetcode.cn/problems/basic-calculator/</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Algorithms </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xv6 Lab Utilities</title>
      <link href="/Blog/2022/07/08/Xv6/Xv6-Lab-Utilities/"/>
      <url>/Blog/2022/07/08/Xv6/Xv6-Lab-Utilities/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考: <a href="https://clownote.github.io/2021/02/24/xv6/Xv6-Lab-Utilities/">Lab: Xv6 and Unix utilities</a></p></blockquote><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>Implement the UNIX program <code>sleep</code> for xv6; your <code>sleep</code> should pause for a user-specified number of ticks. A tick is a notion of time defined by the xv6 kernel, namely the time between two interrupts from the timer chip. Your solution should be in the file <code>user/sleep.c</code>.</p><p>Some hints:</p><ul><li>Before you start coding, read Chapter 1 of the <a href="https://pdos.csail.mit.edu/6.S081/2020/xv6/book-riscv-rev1.pdf">xv6 book</a>.</li><li>Look at some of the other programs in <code>user/</code> (e.g., <code>user/echo.c</code>, <code>user/grep.c</code>, and <code>user/rm.c</code>) to see how you can obtain the command-line arguments passed to a program.</li><li>If the user forgets to pass an argument, sleep should print an error message.</li><li>The command-line argument is passed as a string; you can convert it to an integer using <code>atoi</code> (see user&#x2F;ulib.c).</li><li>Use the system call <code>sleep</code>.</li><li>See <code>kernel/sysproc.c</code> for the xv6 kernel code that implements the <code>sleep</code> system call (look for <code>sys_sleep</code>), <code>user/user.h</code> for the C definition of <code>sleep</code> callable from a user program, and <code>user/usys.S</code> for the assembler code that jumps from user code into the kernel for <code>sleep</code>.</li><li>Make sure <code>main</code> calls <code>exit()</code> in order to exit your program.</li><li>Add your <code>sleep</code> program to <code>UPROGS</code> in Makefile; once you’ve done that, <code>make qemu</code> will compile your program and you’ll be able to run it from the xv6 shell.</li><li>Look at Kernighan and Ritchie’s book <em>The C programming language (second edition)</em> (K&amp;R) to learn about C.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> ticks;  <span class="comment">// time to sleep</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: sleep ticks\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  ticks = atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">  sleep(ticks);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>build &amp; run:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ <span class="built_in">sleep</span> 10</span><br><span class="line">(nothing happens <span class="keyword">for</span> a little <span class="keyword">while</span>)</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h2 id="pingpong"><a href="#pingpong" class="headerlink" title="pingpong"></a>pingpong</h2><p>Write a program that uses UNIX system calls to ‘’ping-pong’’ a byte between two processes over a pair of pipes, one for each direction. The parent should send a byte to the child; the child should print “<code>&lt;pid&gt;: received ping</code>“, where <code>&lt;pid&gt;</code> is its process ID, write the byte on the pipe to the parent, and exit; the parent should read the byte from the child, print “<code>&lt;pid&gt;: received pong</code>“, and exit. Your solution should be in the file <code>user/pingpong.c</code>.</p><p>Some hints:</p><ul><li>Use <code>pipe</code> to create a pipe.</li><li>Use <code>fork</code> to create a child.</li><li>Use <code>read</code> to read from the pipe, and <code>write</code> to write to the pipe.</li><li>Use <code>getpid</code> to find the process ID of the calling process.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li><li>User programs on xv6 have a limited set of library functions available to them. You can see the list in <code>user/user.h</code>; the source (other than for system calls) is in <code>user/ulib.c</code>, <code>user/printf.c</code>, and <code>user/umalloc.c</code>.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> p[<span class="number">2</span>];  <span class="comment">// file descriptors for pipe</span></span><br><span class="line"><span class="type">char</span> recv_buf[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">pipe(p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// child</span></span><br><span class="line">read(p[<span class="number">0</span>], recv_buf, <span class="number">4</span>);</span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>, getpid(), recv_buf);</span><br><span class="line"></span><br><span class="line">write(p[<span class="number">1</span>], <span class="string">&quot;pong&quot;</span>, <span class="number">4</span>);</span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  <span class="comment">// parent</span></span><br><span class="line">write(p[<span class="number">1</span>], <span class="string">&quot;ping&quot;</span>, <span class="number">4</span>);</span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">read(p[<span class="number">0</span>], recv_buf, <span class="number">4</span>);</span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d: received %s\n&quot;</span>, getpid(), recv_buf);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Result:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br><span class="line">...</span><br><span class="line">init: starting sh</span><br><span class="line">$ pingpong</span><br><span class="line">4: received ping</span><br><span class="line">3: received pong</span><br></pre></td></tr></table></figure><h2 id="primes"><a href="#primes" class="headerlink" title="primes"></a>primes</h2><p>Write a concurrent version of prime sieve using pipes. This idea is due to Doug McIlroy, inventor of Unix pipes. The picture halfway down <a href="http://swtch.com/~rsc/thread/">this page</a> and the surrounding text explain how to do it. Your solution should be in the file <code>user/primes.c</code>.</p><p>Your goal is to use <code>pipe</code> and <code>fork</code> to set up the pipeline. The first process feeds the numbers 2 through 35 into the pipeline. For each prime number, you will arrange to create one process that reads from its left neighbor over a pipe and writes to its right neighbor over another pipe. Since xv6 has limited number of file descriptors and processes, the first process can stop at 35.</p><p>Some hints:</p><ul><li>Be careful to close file descriptors that a process doesn’t need, because otherwise your program will run xv6 out of resources before the first process reaches 35.</li><li>Once the first process reaches 35, it should wait until the entire pipeline terminates, including all children, grandchildren, &amp;c. Thus the main primes process should only exit after all the output has been printed, and after all the other primes processes have exited.</li><li>Hint: <code>read</code> returns zero when the write-side of a pipe is closed.</li><li>It’s simplest to directly write 32-bit (4-byte) <code>int</code>s to the pipes, rather than using formatted ASCII I&#x2F;O.</li><li>You should create the processes in the pipeline only as they are needed.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li></ul><p>例程1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 36</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIRST_PRIME 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">generate_natural</span><span class="params">()</span>;  <span class="comment">// -&gt; out_fd</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">prime_filter</span><span class="params">(<span class="type">int</span> in_fd, <span class="type">int</span> prime)</span>;  <span class="comment">// -&gt; out_fd</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> prime;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> in = generate_natural();</span><br><span class="line"><span class="keyword">while</span> (read(in, &amp;prime, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line"><span class="comment">// printf(&quot;prime %d: in_fd: %d\n&quot;, prime, in);  // debug</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;prime %d\n&quot;</span>, prime);</span><br><span class="line">in = prime_filter(in, prime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成自然数: 2, 3, 4, ..&lt; MAX</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">generate_natural</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> out_pipe[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">pipe(out_pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = FIRST_PRIME; i &lt; MAX; i++) &#123;</span><br><span class="line">write(out_pipe[<span class="number">1</span>], &amp;i, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line">close(out_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(out_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out_pipe[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 素数筛</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">prime_filter</span><span class="params">(<span class="type">int</span> in_fd, <span class="type">int</span> prime)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span> out_pipe[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">pipe(out_pipe);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line"><span class="keyword">while</span> (read(in_fd, &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>))) &#123;</span><br><span class="line"><span class="keyword">if</span> (num % prime) &#123;</span><br><span class="line">write(out_pipe[<span class="number">1</span>], &amp;num, <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(in_fd);</span><br><span class="line">close(out_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(in_fd);</span><br><span class="line">close(out_pipe[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> out_pipe[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序是参考 《<a href="https://chai2010.cn/advanced-go-programming-book/">Go语言高级编程</a>》<a href="https://chai2010.cn/advanced-go-programming-book/ch1-basic/ch1-06-goroutine.html">1.6 常见的并发模式</a> 中的那个 Golang 版本写的。Golang 的并发模型和 UNIX Pipe 本身就很像（refer: <a href="https://golang.google.cn/doc/effective_go#sharing">Effective Go: Share by communicating</a>），这里只需把 chan 换成 pipe，Goroutine 换成 fork 的进程。但是，一定要、一定要、一定要注意那些在子进程中使用的文件描述符，父进程不用就要关了，不然就凉了。</p><p>例程2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">source</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="keyword">for</span> (num=<span class="number">2</span>;num&lt;<span class="number">35</span>;num++)&#123;</span><br><span class="line">write(<span class="number">1</span>,&amp;num, <span class="keyword">sizeof</span>(num));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">filter</span><span class="params">(<span class="type">int</span> p)</span>&#123;</span><br><span class="line"><span class="type">int</span> n ;</span><br><span class="line"><span class="keyword">while</span>(read(<span class="number">0</span>,&amp;n,<span class="keyword">sizeof</span>(n)))&#123;</span><br><span class="line"><span class="keyword">if</span> (n%p !=<span class="number">0</span>)&#123;write(<span class="number">1</span>,&amp;n,<span class="keyword">sizeof</span>(n));&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">redirect</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> pd[])</span>&#123;</span><br><span class="line">close(k);</span><br><span class="line">dup(pd[k]);</span><br><span class="line">close(pd[<span class="number">0</span>]);</span><br><span class="line">close(pd[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sink</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> pd[<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> p;</span><br><span class="line"><span class="keyword">if</span>(read(<span class="number">0</span>,&amp;p,<span class="keyword">sizeof</span>(p)))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;prime: %d\n&quot;</span>, p);</span><br><span class="line">pipe(pd);</span><br><span class="line"><span class="keyword">if</span>(fork())&#123;</span><br><span class="line">redirect(<span class="number">0</span>,pd);</span><br><span class="line">sink();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">redirect(<span class="number">1</span>,pd);</span><br><span class="line">filter(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> pd[<span class="number">2</span>];</span><br><span class="line">pipe(pd);</span><br><span class="line"><span class="keyword">if</span>(fork()&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">// parent process redirects the standard input to pd[0]</span></span><br><span class="line">redirect(<span class="number">0</span>,pd);</span><br><span class="line">sink();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//child process redirect the standard ouput to pd[1]</span></span><br><span class="line">redirect(<span class="number">1</span>, pd);</span><br><span class="line">source();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>运行·结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ primes</span><br><span class="line">prime 2</span><br><span class="line">prime 3</span><br><span class="line">prime 5</span><br><span class="line">prime 7</span><br><span class="line">prime 11</span><br><span class="line">prime 13</span><br><span class="line">prime 17</span><br><span class="line">prime 19</span><br><span class="line">prime 23</span><br><span class="line">prime 29</span><br><span class="line">prime 31</span><br></pre></td></tr></table></figure><h2 id="find"><a href="#find" class="headerlink" title="find"></a>find</h2><p>Write a simple version of the UNIX find program: find all the files in a directory tree with a specific name. Your solution should be in the file <code>user/find.c</code>.</p><p>Some hints:</p><ul><li>Look at user&#x2F;ls.c to see how to read directories.</li><li>Use recursion to allow find to descend into sub-directories.</li><li>Don’t recurse into “.” and “..”.</li><li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li><li>You’ll need to use C strings. Have a look at K&amp;R (the C book), for example Section 5.5.</li><li>Note that &#x3D;&#x3D; does not compare strings like in Python. Use strcmp() instead.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fs.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>*</span><br><span class="line"><span class="title function_">fmtname</span><span class="params">(<span class="type">char</span> *path)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Find first character after last slash.</span></span><br><span class="line"><span class="keyword">for</span>(p=path+<span class="built_in">strlen</span>(path); p &gt;= path &amp;&amp; *p != <span class="string">&#x27;/&#x27;</span>; p--)</span><br><span class="line">;</span><br><span class="line">p++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">find</span><span class="params">(<span class="type">char</span> *path, <span class="type">char</span> *targetname)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">512</span>], *p;</span><br><span class="line"><span class="type">int</span> fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> <span class="title">de</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(fmtname(path), targetname)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((fd = open(path, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot open [%s], fd=%d\n&quot;</span>, path, fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fstat(fd, &amp;st) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;find: cannot stat %s\n&quot;</span>, path);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (st.type != T_DIR) &#123;</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// st.type == T_DIR</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(path) + <span class="number">1</span> + DIRSIZ + <span class="number">1</span> &gt; <span class="keyword">sizeof</span> buf) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;find: path too long\n&quot;</span>);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(buf, path);</span><br><span class="line">p = buf+<span class="built_in">strlen</span>(buf);</span><br><span class="line">*p++ = <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span> (read(fd, &amp;de, <span class="keyword">sizeof</span>(de)) == <span class="keyword">sizeof</span>(de)) &#123;</span><br><span class="line"><span class="keyword">if</span> (de.inum == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">memmove(p, de.name, DIRSIZ);</span><br><span class="line">p[DIRSIZ] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;.&quot;</span>) || !<span class="built_in">strcmp</span>(de.name, <span class="string">&quot;..&quot;</span>))</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">find(buf, targetname);</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(argc &lt; <span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: find path filename\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">find(argv[<span class="number">1</span>], argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要就是抄 <code>user/ls.c</code>。这个指针玩的，，太骚了[捂脸]: $path$被复制到$buf$，然后创建一个指针$*p$指向$buf$的首字符地址，后面加一个“&#x2F;”，接着把$p$递增指向下一位。这样做有什么好处呢，之后只需要不停从fd读取文件名，此处$de$是$dirent$，是文件标志符的基本单元，定义在$“kernel&#x2F;fs.h”$中。然后不断把$de.name$通过$memmove$这个函数赋值给指针$p$。然后从$buf$的首地址读取会得到当前文件的全地址。同时该函数用到了递归，知道吧目标路径和其所有子路径的文件都对比一遍，发现目标文件名则输出全地址，否则查完收工。</p><p>结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> &gt; b</span><br><span class="line">$ <span class="built_in">mkdir</span> a</span><br><span class="line">$ <span class="built_in">echo</span> &gt; a/b</span><br><span class="line">$ find . b</span><br><span class="line">./b</span><br><span class="line">./a/b</span><br></pre></td></tr></table></figure><h2 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h2><p>Write a simple version of the UNIX xargs program: read lines from the standard input and run a command for each line, supplying the line as arguments to the command. Your solution should be in the file <code>user/xargs.c</code>.</p><p>The following example illustrates xarg’s behavior:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello too | xargs <span class="built_in">echo</span> <span class="built_in">bye</span></span><br><span class="line"><span class="built_in">bye</span> hello too</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>Note that the command here is “echo bye” and the additional arguments are “hello too”, making the command “echo bye hello too”, which outputs “bye hello too”.</p><p>Please note that xargs on UNIX makes an optimization where it will feed more than argument to the command at a time. We don’t expect you to make this optimization. To make xargs on UNIX behave the way we want it to for this lab, please run it with the -n option set to 1. For instance</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;1\n2&quot;</span> | xargs -n 1 <span class="built_in">echo</span> line</span><br><span class="line">line 1</span><br><span class="line">line 2</span><br><span class="line">$</span><br></pre></td></tr></table></figure><p>Some hints:</p><ul><li>Use <code>fork</code> and <code>exec</code> to invoke the command on each line of input. Use <code>wait</code> in the parent to wait for the child to complete the command.</li><li>To read individual lines of input, read a character at a time until a newline (‘\n’) appears.</li><li>kernel&#x2F;param.h declares MAXARG, which may be useful if you need to declare an argv array.</li><li>Add the program to <code>UPROGS</code> in Makefile.</li><li>Changes to the file system persist across runs of qemu; to get a clean file system run make clean and then make qemu.</li></ul><p>xargs, find, and grep combine well:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ find . b | xargs grep hello</span><br></pre></td></tr></table></figure><p>will run “grep hello” on each file named b in the directories below “.”.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/param.h&quot;</span>  <span class="comment">// MAXARG</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> is_blank(chr) (chr == <span class="string">&#x27; &#x27;</span> || chr == <span class="string">&#x27;\t&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">2048</span>], ch;</span><br><span class="line"><span class="type">char</span> *p = buf;</span><br><span class="line"><span class="type">char</span> *v[MAXARG]; <span class="comment">// declares p as an array of MAXARG pointers</span></span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="type">int</span> blanks = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> offset = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(argc &lt;= <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;usage: xargs &lt;command&gt; [argv...]\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (c = <span class="number">1</span>; c &lt; argc; c++) &#123;</span><br><span class="line">v[c<span class="number">-1</span>] = argv[c];</span><br><span class="line">&#125;</span><br><span class="line">--c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (read(<span class="number">0</span>, &amp;ch, <span class="number">1</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (is_blank(ch)) &#123;</span><br><span class="line">blanks++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (blanks) &#123;  <span class="comment">// 之前有过空格</span></span><br><span class="line">buf[offset++] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">v[c++] = p;</span><br><span class="line">p = buf + offset;</span><br><span class="line"></span><br><span class="line">blanks = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ch != <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">buf[offset++] = ch;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">v[c++] = p;</span><br><span class="line">p = buf + offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line"><span class="built_in">exit</span>(exec(v[<span class="number">0</span>], v));</span><br><span class="line">&#125;</span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">c = argc - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要是字符串操作麻烦。。知识点回顾：</p><ul><li>数组名只有在$sizeof(数组名)$ 和$&amp;数组名$ 两种情况表示整个数组的地址， 其他情况表示数组首元素的地址。</li><li>故而: $&amp;a$和$&amp;a[0]$虽然值是一样，但是返回的类型不一样，前者是指向数组的地址，后者是指向数组首元素的地址，前者的指针+1 指向下一个数组，后者+1指向该数组的第二个元素。但是$a$与$&amp;a[0]$是一样的。</li><li>$int *p[3]$ 声明一个数组p，包含三个指针元素， 指针元素各都指向一个integer; $int(*p)[3]$声明一个数组指针p，数组包含三个integer。</li></ul><p>运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello too | xargs <span class="built_in">echo</span> <span class="built_in">bye</span></span><br><span class="line"><span class="built_in">bye</span> hello too</span><br><span class="line">$ find . b</span><br><span class="line">./b</span><br><span class="line">./a/b</span><br><span class="line">$ find . b | xargs <span class="built_in">echo</span> hello</span><br><span class="line">hello ./b</span><br><span class="line">hello ./a/b</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li>MIT. Lab guidance. <a href="https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html">https://pdos.csail.mit.edu/6.S081/2020/labs/guidance.html</a></li><li>MIT. Lab: Xv6 and Unix utilities. <a href="https://pdos.csail.mit.edu/6.S081/2020/labs/util.html">https://pdos.csail.mit.edu/6.S081/2020/labs/util.html</a></li><li>KatyuMarisa. MIT 6.S081 xv6调试不完全指北. <a href="https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html">https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html</a></li><li>lhw–9999. xv6操作系统实验 – 质数筛. <a href="https://blog.csdn.net/lhwhit/article/details/108342724">https://blog.csdn.net/lhwhit/article/details/108342724</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xv6 编写用户程序</title>
      <link href="/Blog/2022/06/21/Xv6/Xv6-add-user-program/"/>
      <url>/Blog/2022/06/21/Xv6/Xv6-add-user-program/</url>
      
        <content type="html"><![CDATA[<h1 id="Xv6-编写用户程序"><a href="#Xv6-编写用户程序" class="headerlink" title="Xv6 编写用户程序"></a>Xv6 编写用户程序</h1><p>如何在 Xv6（<a href="https://github.com/mit-pdos/xv6-riscv">xv6-riscv</a>）中添加自己编写的用户程序，比如实现一个 <code>helloworld</code>？</p><h2 id="1-编写代码"><a href="#1-编写代码" class="headerlink" title="1. 编写代码"></a>1. 编写代码</h2><p>在 <code>xv6-riscv/user/</code> 里新建一个 <code>helloworld.c</code>，写一个 hello world：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个和平时我们在真实系统中写的代码有少许区别：</p><ol><li>导库：<code>kernel/types.h</code>, <code>kernel/stat.h</code>, <code>user/user.h</code>。你可以看到  <code>xv6-riscv/user/*.c</code> 头三行基本都是这么写的，咱们有样学样就可。（这三行大概就是 include <code>&lt;stdio.h&gt;</code>，<code>&lt;stdlib.h&gt;</code>，<code>&lt;unistd.h&gt;</code> ）</li><li>不要 <code>return 0;</code>，要 <code>exit(0);</code>（否则你会得到一个运行时的 <code> unexpected scause 0x000000000000000f</code>）。这一点同样可以参考其他系统随附的程序得出。</li></ol><h2 id="2-修改-Makefile"><a href="#2-修改-Makefile" class="headerlink" title="2. 修改 Makefile"></a>2. 修改 Makefile</h2><p><code>Xv6</code> 系统中没有编译器的实现，所以我们需要把程序在编译系统时一并编译。修改 <code>xv6-riscv/Makefile</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim Makefile</span><br></pre></td></tr></table></figure><p>找到 <code>UPROGS</code> (大概118行)，保持格式，在后面添加注册新程序：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">UPROGS=\</span><br><span class="line">$U/_cat\</span><br><span class="line">$U/_echo\</span><br><span class="line">...</span><br><span class="line">$U/_helloworld\</span><br></pre></td></tr></table></figure><p>编写的代码 <code>user/xxx.c</code>，对应这里写 <code>$U/_xxx\</code>。</p><h2 id="3-编译运行-Xv6"><a href="#3-编译运行-Xv6" class="headerlink" title="3. 编译运行 Xv6"></a>3. 编译运行 Xv6</h2><p>编译运行 Xv6：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ make qemu</span><br></pre></td></tr></table></figure><p>在 Xv6 中 <code>ls</code>，可以看到我们的 helloworld 程序：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">...</span><br><span class="line">helloworld   2 20 22352</span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ helloworld</span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>That’s it!</p><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># By CDFMLR 2021-02-17</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;See you.&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xv6 多进程编程</title>
      <link href="/Blog/2022/06/21/Xv6/Xv6-Processes/"/>
      <url>/Blog/2022/06/21/Xv6/Xv6-Processes/</url>
      
        <content type="html"><![CDATA[<h1 id="Xv6-多进程编程"><a href="#Xv6-多进程编程" class="headerlink" title="Xv6 多进程编程"></a>Xv6 多进程编程</h1><blockquote><p>参考: <a href="https://github.com/mit-pdos/xv6-riscv-book">xv6-riscv-book</a> 1.1 Processes and memory</p></blockquote><p>本文参考 xv6-riscv-book，介绍如何使用 Xv6 系统调用，实现多进程编程。（其实就是把书上的代码完整化，并附上真实系统中的实现方式）</p><table><thead><tr><th>系统调用</th><th>描述</th></tr></thead><tbody><tr><td><code>int fork()</code></td><td>创建一个进程（通过复制当前进程）返回子进程 PID</td></tr><tr><td><code>int exit(int status)</code></td><td>终止当前进程，status 会被报告给 wait()，无返回值</td></tr><tr><td><code>int wait(int *status)</code></td><td>等待一个子进程退出，把退出的状态(exit de status) 写到 status，返回退出的子进程 PID</td></tr><tr><td><code>int exec(char *file, char *argv[])</code></td><td>载入一个文件，并以指定参数执行之。错误才返回</td></tr></tbody></table><h2 id="fork-amp-wait"><a href="#fork-amp-wait" class="headerlink" title="fork &amp; wait"></a>fork &amp; wait</h2><p>fork 系统调用通过复制当前进程，创建一个进程，返回子进程 PID。</p><p>wait 会等待当前进程的某个子进程退出（调用 exit）。</p><h3 id="Xv6"><a href="#Xv6" class="headerlink" title="Xv6"></a>Xv6</h3><p>书上有关使用 <code>fork</code> 的代码的完整实现（在 Xv6 下运行。Help: <a href="https://blog.csdn.net/u012419550/article/details/113836258">Xv6 编写用户程序</a>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usefork.c for xv6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">pid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在 Xv6 里提供的 printf 线程不安全，运行程序打印出的字符可能随机混合在一起：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ usefork   <span class="comment"># 这个还稍好</span></span><br><span class="line">parent: child=c5</span><br><span class="line">hild: exiting</span><br><span class="line">child 5 is <span class="keyword">done</span></span><br><span class="line">$ usefork  <span class="comment"># 这个就非常乱了</span></span><br><span class="line">cphairledn:t :e xcihtiilndg=</span><br><span class="line">7</span><br><span class="line">child 7 is <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="Real-Unix"><a href="#Real-Unix" class="headerlink" title="Real Unix"></a>Real Unix</h3><p>在真实的 <code>*nix</code> 系统上（这里以 macOS 11，GCC 10 为例），这段代码的写法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usefork.c for macOS GCC</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent: child=%d\n&quot;</span>, pid);</span><br><span class="line">pid = wait((<span class="type">int</span> *) <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child %d is done\n&quot;</span>, pid);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child: exiting\n&quot;</span>);</span><br><span class="line"><span class="comment">// sleep(2);</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;fork error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>真实系统中运行的效果会好一些，一般没有字符混合的情况：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ gcc-10 usefork.c ; ./a.out</span><br><span class="line">parent: child=3598</span><br><span class="line">child: exiting</span><br><span class="line">child 3598 is <span class="keyword">done</span></span><br></pre></td></tr></table></figure><h2 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h2><p>exec 系统调用载入一个可执行文件，用其替换自身程序，以指定参数执行之。</p><h3 id="Xv6-1"><a href="#Xv6-1" class="headerlink" title="Xv6"></a>Xv6</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useexec.c for Xv6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">exec(<span class="string">&quot;echo&quot;</span>, argv);</span><br><span class="line"><span class="comment">// exec 成功了会替换程序，下面的就执行不到了:</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ useexec</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h3 id="Real-Unix-1"><a href="#Real-Unix-1" class="headerlink" title="Real Unix"></a>Real Unix</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useexec.c for macOS</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;echo&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">execv(<span class="string">&quot;/bin/echo&quot;</span>, argv);</span><br><span class="line"><span class="comment">// execv(&quot;/bin/echooooo&quot;, argv);  // an error one</span></span><br><span class="line"><span class="comment">// exec 成功了会替换程序，下面的就执行不到了:</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;exec error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc-10 useexec.c ; ./a.out</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><hr><p>正文结束。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># By CDFMLR 2021-02-18</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;See you.🥷&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xv6 管道</title>
      <link href="/Blog/2022/06/20/Xv6/Xv6-pipes/"/>
      <url>/Blog/2022/06/20/Xv6/Xv6-pipes/</url>
      
        <content type="html"><![CDATA[<h1 id="Xv6-管道"><a href="#Xv6-管道" class="headerlink" title="Xv6 管道"></a>Xv6 管道</h1><blockquote><p>参考: <a href="https://github.com/mit-pdos/xv6-riscv-book">xv6-riscv-book</a> 1.3 Pipes</p></blockquote><p>[TOC]</p><h2 id="pipe"><a href="#pipe" class="headerlink" title="pipe"></a>pipe</h2><p>Xv6 系统调用 <code>pipe()</code> 来创建管道。管道类似于 Go 语言中的 chan。在 Shell 里我们用 <code>|</code> 表示管道，对于命令： <code>echo &quot;hello world&quot; | wc</code>，可以用如下代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// upipe.c</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Runs the program wc with standard input connected to the read end of a pipe.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> p[<span class="number">2</span>];  <span class="comment">// file descriptors for the pipe</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;wc&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;  <span class="comment">// NULL</span></span><br><span class="line"></span><br><span class="line">pipe(p);  <span class="comment">// creates a new pipe: records the read and write file descriptors in the array p</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// redirection</span></span><br><span class="line">close(<span class="number">0</span>);</span><br><span class="line">dup(p[<span class="number">0</span>]);  <span class="comment">// stdin = &lt;- pipe</span></span><br><span class="line"></span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">exec(<span class="string">&quot;wc&quot;</span>, argv);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">close(p[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">write(p[<span class="number">1</span>], <span class="string">&quot;hello world\n&quot;</span>, <span class="number">12</span>);  <span class="comment">// pipe &lt;- str</span></span><br><span class="line"></span><br><span class="line">close(p[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ upipe</span><br><span class="line">1 2 12</span><br></pre></td></tr></table></figure><p>Xv6 sh 里的管道处理实现其实就和这段代码类似：fork 两个进程，分别重定向标准输出 or 输入、运行管道左右两边的命令。详见 <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/sh.c#L100">user&#x2F;sh.c:100</a>。</p><h2 id="管道-V-S-临时文件"><a href="#管道-V-S-临时文件" class="headerlink" title="管道 V.S. 临时文件"></a>管道 V.S. 临时文件</h2><p>用管道与用临时文件，使用上似乎区别不大：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 管道</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> | <span class="built_in">wc</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 临时文件</span></span><br><span class="line"><span class="built_in">echo</span> hello world &gt;/tmp/xyz; <span class="built_in">wc</span> &lt;/tmp/xyz</span><br></pre></td></tr></table></figure><p>但管道更好：</p><ul><li>管道会自动清理（临时文件要手动删除）</li><li>管道可以放任意长度的数据流（临时文件需要有足够的磁盘空间）</li><li>管道可以并行运行（临时文件只能一个运行完，第二个再开始）</li><li>在处理进程间通信问题时，管道的阻塞式读写比用非阻塞的临时文件方便。</li></ul><hr><p>EOF</p><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># By CDFMLR 2021-02-20</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;See you. 🪐&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xv6 I/O 与文件描述符</title>
      <link href="/Blog/2022/06/18/Xv6/Xv6-io-and-file-descriptors/"/>
      <url>/Blog/2022/06/18/Xv6/Xv6-io-and-file-descriptors/</url>
      
        <content type="html"><![CDATA[<h1 id="Xv6-I-x2F-O-与文件描述符"><a href="#Xv6-I-x2F-O-与文件描述符" class="headerlink" title="Xv6 I&#x2F;O 与文件描述符"></a>Xv6 I&#x2F;O 与文件描述符</h1><blockquote><p>参考: <a href="https://github.com/mit-pdos/xv6-riscv-book">xv6-riscv-book</a> 1.2 I&#x2F;O and File descriptors</p></blockquote><h2 id="Xv6-I-x2F-O-系统调用"><a href="#Xv6-I-x2F-O-系统调用" class="headerlink" title="Xv6 I&#x2F;O 系统调用"></a>Xv6 I&#x2F;O 系统调用</h2><p>本文会使用到如下 Xv6 的 I&#x2F;O 系统调用：</p><table><thead><tr><th>系统调用</th><th>说明</th></tr></thead><tbody><tr><td>int open(char *file, int flags)</td><td>打开一个文件，flags 用来指示读or写，返回一个文件描述符</td></tr><tr><td>int write(int fd, char *buf, int n)</td><td>从 buf 写 n 个字节到文件描述符 fd，返回写入的字节数</td></tr><tr><td>int read(int fd, char *buf, int n)</td><td>从文件描述符 fd 读 n 个字节到 buf，返回读取的字节数或 <code>0</code> 表示 EOF（文件结束）</td></tr><tr><td>int close(int fd)</td><td>释放打开的文件描述符 fd</td></tr><tr><td>int dup(int fd)</td><td>返回一个新的文件描述符，指向与 fd 相同的文件</td></tr></tbody></table><p>open 的 flags 由 <a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//kernel/fcntl.h#L1-L5"> kernel&#x2F;fcntl.h:1-5</a> 提供：</p><table><thead><tr><th>flag</th><th>说明</th></tr></thead><tbody><tr><td>O_RDONLY</td><td>只读</td></tr><tr><td>O_WRONLY</td><td>只写</td></tr><tr><td>O_RDWR</td><td>读和写</td></tr><tr><td>O_CREATE</td><td>不存在时新建</td></tr><tr><td>O_TRUNC</td><td>把文件截断到 0 长度</td></tr></tbody></table><p>这些都是用 bit 描述的，可以做或运算：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">&quot;/dir/file&quot;</span>, O_CREATE|O_WRONLY);</span><br></pre></td></tr></table></figure><h2 id="Xv6-文件描述符"><a href="#Xv6-文件描述符" class="headerlink" title="Xv6 文件描述符"></a>Xv6 文件描述符</h2><p>文件描述符就是一个整数，用来代表一个打开的 IO 对象（如文件），通过文件描述符就可以对 IO 对象进行读写操作。程序一开始就会被分配给如下惯例文件描述符：</p><table><thead><tr><th>文件描述符</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>stdin  标准输入</td></tr><tr><td>1</td><td>stdout 标准输出</td></tr><tr><td>2</td><td>stderr 标准错误</td></tr></tbody></table><h2 id="read-amp-write"><a href="#read-amp-write" class="headerlink" title="read &amp; write"></a>read &amp; write</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// useio.c</span></span><br><span class="line"><span class="comment">// Copies data from its standard input to its standard output.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> buf[<span class="number">512</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">n = read(<span class="number">0</span>, buf, <span class="keyword">sizeof</span> buf);  <span class="comment">// 0: stdin</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;  <span class="comment">// EOF</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;read error\n&quot;</span>);  <span class="comment">// 2: stderr</span></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (write(<span class="number">1</span>, buf, n) != n) &#123;  <span class="comment">// 1: stdout</span></span><br><span class="line"><span class="built_in">fprintf</span>(<span class="number">2</span>, <span class="string">&quot;write error\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序从标准输入读，写到标准输出，相当于一个简化的 cat：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ useio &gt; fff</span><br><span class="line">123456  <span class="comment"># 这是输入的</span></span><br><span class="line">$ useio &lt; fff</span><br><span class="line">123456  <span class="comment"># 这是输出的</span></span><br></pre></td></tr></table></figure><h2 id="重定向的实现"><a href="#重定向的实现" class="headerlink" title="重定向的实现"></a>重定向的实现</h2><p>在通过如 open 的系统调用打开一个文件时，被分配给的文件描述符总是当前可用的描述符中<strong>最小的</strong>。</p><p>用这个特性就可以实现输入输出的重定向。Xv6 的 Shell (<a href="https://github.com/mit-pdos/xv6-riscv/blob/riscv//user/sh.c#L82">user&#x2F;sh.c:82</a>) 里就是这么实现的。</p><p>下面的程序实现一个 <code>cat &lt; input.txt</code> 的效果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// uredirection.c</span></span><br><span class="line"><span class="comment">// A simplified version of the code a shell runs for the command `cat &lt; input.txt`</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span>  <span class="comment">// define O_RDONLY</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> *argv[<span class="number">2</span>];</span><br><span class="line">argv[<span class="number">0</span>] = <span class="string">&quot;cat&quot;</span>;</span><br><span class="line">argv[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;  <span class="comment">// subprocess</span></span><br><span class="line">close(<span class="number">0</span>);  <span class="comment">// close stdin</span></span><br><span class="line"><span class="comment">// A newly allocated file descriptor is always the lowest-numbered unused descriptor of the current process.</span></span><br><span class="line">open(<span class="string">&quot;input.txt&quot;</span>, O_RDONLY);  <span class="comment">// 0 =&gt; input.txt</span></span><br><span class="line"><span class="comment">// exec replaces the calling process’s memory but preserves its file table.</span></span><br><span class="line">exec(<span class="string">&quot;cat&quot;</span>, argv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cat &gt; input.txt</span><br><span class="line">&lt;Input something here&gt;</span><br><span class="line">$ uredirection</span><br><span class="line">&lt;what is inputted above&gt;</span><br></pre></td></tr></table></figure><p>fork 和 exec 分离的一个好处就是 shell 可以在 fork 和 exec 之间优雅实现重定向，如上面的程序。如果把二者合并，提供一个 <code>forkexec</code>  系统调用，重定向的实现就很烦了：需要多传参数；或者在调用 forkexec 前设置 shell 进程自己的描述符，然后又改回去；或者让每个程序自己去支持重定向。</p><h2 id="共享偏移"><a href="#共享偏移" class="headerlink" title="共享偏移"></a>共享偏移</h2><p>fork 的时候会拷贝文件描述符表，但每个文件的偏移量（读&#x2F;写到哪）会在父子进程间共享。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// usharedoffset.c</span></span><br><span class="line"><span class="comment">// Although fork copies the file descriptor table, each underlying file offset is shared between parent and child.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (fork() == <span class="number">0</span>) &#123;</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">wait(<span class="number">0</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;&quot;</span> &gt; output.txt</span><br><span class="line">$ usharedoffset &gt; output.txt</span><br><span class="line">$ <span class="built_in">cat</span> output.txt</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><p>dup “复制”一个现有的文件描述符，返回的新描述符指向和原来一样的 I&#x2F;O 物体（比如文件）。类似于 fork，新旧文件描述符共享 offset。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// udup.c</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The dup system call duplicates an existing file descriptor,</span></span><br><span class="line"><span class="comment">// returning a new one that refers to the same underlying I/O object.</span></span><br><span class="line"><span class="comment">// Both file descriptors share an offset, just as the file descriptors</span></span><br><span class="line"><span class="comment">// duplicated by fork do.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/types.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/stat.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user/user.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel/fcntl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">int</span> fd = dup(<span class="number">1</span>);</span><br><span class="line">write(<span class="number">1</span>, <span class="string">&quot;hello &quot;</span>, <span class="number">6</span>);</span><br><span class="line">write(fd, <span class="string">&quot;world\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ udup &gt; output.txt</span><br><span class="line">$ <span class="built_in">cat</span> output.txt</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>利用 dup，shell 就可以实现 <code>ls existing-file non-existing-file &gt; tmp1 2&gt;&amp;1</code> 了。 <code>2&gt;&amp;1</code> 就是 <code>2 = dup(1)</code>，让标准错误和标准输出指向同一个文件，并且共享偏移（一直往后写）。</p><hr><p>EOF</p><hr><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># By CDFMLR 2021-02-18</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;See you.🧑‍💻&quot;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Xv6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL- Databases and Tables(1)</title>
      <link href="/Blog/2021/09/20/MySQL/MySQL/"/>
      <url>/Blog/2021/09/20/MySQL/MySQL/</url>
      
        <content type="html"><![CDATA[<h2 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h2><p>This article is general commands of MySQL in database and table operations. The structure follows the course content of <a href="https://www.udemy.com/course/the-ultimate-mysql-bootcamp-go-from-sql-beginner-to-expert/">The Ultimate MySQL Bootcamp: Go from SQL Beginner to Expert</a>. The article only cover the basic SQL key words. More articles on searching, inter-table relation will be posted later.</p><p> Note: SQL language is case insensitive, however commands and function characters are usually written in uppercase just for easier reading.</p><h2 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h2><p>Database commands:  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># creation <span class="operator">&amp;</span> deletion</span><br><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="operator">&lt;</span>db_name<span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">DROP</span> DATABASE <span class="operator">&lt;</span>db_name<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">check</span> <span class="keyword">all</span> database <span class="operator">&amp;</span> the currently being used</span><br><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br><span class="line"><span class="keyword">SELECT</span> DATABASE();</span><br><span class="line"></span><br><span class="line"># switch <span class="keyword">into</span> a database</span><br><span class="line">USE <span class="operator">&lt;</span>db_name<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><h2 id="Tables"><a href="#Tables" class="headerlink" title="Tables"></a>Tables</h2><h3 id="Creation-amp-Deletion"><a href="#Creation-amp-Deletion" class="headerlink" title="Creation &amp; Deletion"></a>Creation &amp; Deletion</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># creation <span class="operator">&amp;</span> deletion</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span></span><br><span class="line">  (</span><br><span class="line">    column_name1 dataType(size),</span><br><span class="line">    column_name2 dataType(size)</span><br><span class="line">  );</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">check</span> Tables</span><br><span class="line"><span class="keyword">SHOW</span> TABLES;</span><br><span class="line"><span class="keyword">DESC</span> <span class="operator">&lt;</span>tb_name<span class="operator">&gt;</span>; # Descibe the <span class="keyword">table</span> format</span><br></pre></td></tr></table></figure><h3 id="Data-format"><a href="#Data-format" class="headerlink" title="Data format"></a>Data format</h3><p>While creating a table, three settings of the data are commonly considered: default value, $NULL$ or $NOT  NULL$ and entry id. An example is as below to explain:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cats</span><br><span class="line">  (</span><br><span class="line">    cat_id <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    cat_name <span class="type">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;Unknown&#x27;</span>,</span><br><span class="line">    age <span class="type">INT</span></span><br><span class="line">  );</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> cats (cat_name, age)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="string">&#x27;Kate&#x27;</span>, <span class="number">26</span>),</span><br><span class="line">(<span class="string">&#x27;Ron&#x27;</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>Data type in SQL language:</p><table><thead><tr><th align="left">名称</th><th align="left">类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">INT</td><td align="left">整型</td><td align="left">4字节整数类型，范围约+&#x2F;-21亿</td></tr><tr><td align="left">BIGINT</td><td align="left">长整型</td><td align="left">8字节整数类型，范围约+&#x2F;-922亿亿</td></tr><tr><td align="left">REAL</td><td align="left">浮点型</td><td align="left">4字节浮点数，范围约+&#x2F;-1038</td></tr><tr><td align="left">DOUBLE</td><td align="left">浮点型</td><td align="left">8字节浮点数，范围约+&#x2F;-10308</td></tr><tr><td align="left">DECIMAL(M,N)</td><td align="left">高精度小数</td><td align="left">由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算</td></tr><tr><td align="left">CHAR(N)</td><td align="left">定长字符串</td><td align="left">存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串</td></tr><tr><td align="left">VARCHAR(N)</td><td align="left">变长字符串</td><td align="left">存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串</td></tr><tr><td align="left">BOOLEAN</td><td align="left">布尔类型</td><td align="left">存储True或者False</td></tr><tr><td align="left">DATE</td><td align="left">日期类型</td><td align="left">存储日期，例如，2018-06-22</td></tr><tr><td align="left">TIME</td><td align="left">时间类型</td><td align="left">存储时间，例如，12:20:59</td></tr><tr><td align="left">DATETIME</td><td align="left">日期和时间类型</td><td align="left">存储日期+时间，例如，2018-06-22 12:20:59</td></tr></tbody></table><h3 id="Make-Changes"><a href="#Make-Changes" class="headerlink" title="Make Changes"></a>Make Changes</h3><p>Now we have some data in the table but we want to do changes:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">delete</span> a <span class="keyword">column</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> cats</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="operator">&lt;</span>column_name<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">update</span> <span class="keyword">some</span> <span class="keyword">values</span></span><br><span class="line"><span class="keyword">UPDATE</span> cats <span class="keyword">SET</span> age <span class="operator">=</span> <span class="number">100</span> <span class="keyword">WHERE</span> <span class="operator">&lt;</span>conditions<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"># conditional Deletion</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> cats <span class="keyword">WHERE</span> <span class="operator">&lt;</span><span class="keyword">condition</span><span class="operator">&gt;</span>;</span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> cats; # This will <span class="keyword">delete</span> <span class="keyword">all</span> data <span class="keyword">in</span> cats <span class="keyword">table</span></span><br></pre></td></tr></table></figure><p>We may also want to print&#x2F;see the data in the table (DESC is only for describing the structure of the table but the content):</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cats; # print <span class="keyword">all</span> Content</span><br><span class="line"><span class="keyword">SELECT</span> column_name1,column_name2 <span class="keyword">FROM</span> cats;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">&lt;</span>column_name<span class="operator">&gt;</span> <span class="keyword">WHERE</span> <span class="operator">&lt;</span>conditions<span class="operator">&gt;</span>;</span><br></pre></td></tr></table></figure><p>Note: $SELECT$ is like a print function and can be combined with other entry functions to look in the table without changing it. Often we want to have the printed column name presented differently by using $AS$:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  column_name1 <span class="keyword">AS</span> c1,</span><br><span class="line">  column_name2 <span class="keyword">AS</span> c2</span><br><span class="line"><span class="keyword">FROM</span> cats;</span><br></pre></td></tr></table></figure><h2 id="String-functions"><a href="#String-functions" class="headerlink" title="String functions"></a>String functions</h2><p>After the general operations on database, tables we enter into entry operations. In this section we look into the five most popular string functions of MySQL.</p><p>To combine data:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONCAT(column_name1, <span class="string">&#x27; &#x27;</span>, column_name2);</span><br><span class="line">CONCAT_WS(<span class="string">&#x27;-&#x27;</span>,column_name1,column_name2);</span><br></pre></td></tr></table></figure><p>The second function above allows add in delimiter. To extract part of the string:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SUBSTRING</span>(<span class="string">&#x27;HELLO WORLD&#x27;</span>,<span class="number">1</span>,<span class="number">7</span>); # <span class="number">1</span> <span class="keyword">to</span> <span class="number">7</span></span><br><span class="line"><span class="built_in">SUBSTRING</span>(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">7</span>); # <span class="number">7</span> <span class="keyword">to</span> <span class="number">-1</span></span><br><span class="line"><span class="built_in">SUBSTRING</span>(<span class="string">&#x27;Hello World&#x27;</span>, <span class="number">-3</span>); # <span class="number">-3</span> <span class="keyword">to</span> <span class="number">-1</span></span><br><span class="line"># The same</span><br><span class="line">SUBSTR(<span class="string">&#x27;Hello World&#x27;</span>,<span class="number">-3</span>);</span><br></pre></td></tr></table></figure><p>To replace part of the string:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLACE(<span class="string">&#x27;Hello World&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;3&#x27;</span>);</span><br></pre></td></tr></table></figure><p>To reverse the string:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REVERSE(<span class="string">&#x27;Hello World&#x27;</span>);</span><br></pre></td></tr></table></figure><p>To count the length of the string:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHAR_LENGTH</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br></pre></td></tr></table></figure><p>To get the upper case or lower case:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UPPER</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line"><span class="built_in">LOWER</span>(<span class="string">&#x27;Hello World&#x27;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
